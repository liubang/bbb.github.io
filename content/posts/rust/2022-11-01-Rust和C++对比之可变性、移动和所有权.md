---
layout: article
title: 'Rust和C+++: 可变性、移动和所有权'
date: 2022-11-01
categories: [programming]
tags: [Rust]
---

## C++和Rust中的const-ness

### 值

Rust和C++有两个相似的概念：Rust中的mutability/immutability和C++中的constness/non-constness.
在Rust中，一个给定的值要么是可变的(mutable)，要么是不可变的(immutable)，正如这些限定符名称所代表的含义，
可变的值可以被修改，不可变的值不能被修改。然而与C++相反的是，Rust中不可变的值可以被移动(move)，就像下面的代码实例那样：

```rust
fn foo() {
    let x = 1;
    println!("{}", x)
    let mut x = x;
    x *= 10;
    println!("{}", x);
}
```

同样的在C++中，给定的值要么是常量(const)，要么是非常量(non-const)。但是C++中的常量值不能被移动(move)。在C++中，对一个const限定符修饰的值
进行`std::move`操作，实际上会触发拷贝构造，这一点在"Effective Modern C++"这本书中作者也有提到：
```cpp
class Annotation {
public:
    explicit Annotation(const std::string text)
     : value(std::move(text)) //here we want to call string(string&&),
                              //but because text is const,
                              //the return type of std::move(text) is const std::string&&
                              //so we actually called string(const string&)
                              //it is a bug which is very hard to find out
    {}
private:
    std::string value;
};
```

我们也可以自己写一段程序来验证一下：

```cpp
#include <iostream>
#include <string>

struct Foo {
  Foo() { std::cout << "default constructor" << std::endl; }
  Foo(const Foo&) { std::cout << "copy constructor" << std::endl; }
  Foo(Foo&&) { std::cout << "move constructor" << std::endl; }
};

int main(int argc, char* argv[]) {
  const Foo foo;
  Foo other = std::move(foo);
  return 0;
}

// 执行结果：
// default constructor
// copy constructor
```

### 引用

引用在C++和Rust中有一些相似。对于这两种语言，引用是一段数据的句柄，它允许程序员在不传递副本的情况下引用该数据。
在这两个语言中，引用都是指针的语法糖。而与指针不同的是，引用或多或少能保证它指向的数据的有效性(至少在创建的时候)。

错误的使用引用是C++中错误的主要来源。而在Rust中提供了更多的安全保证，可以消除大多数这些错误。例如C++并不保证
只要引用存在就一定有效，就像下面这段代码这样：

```cpp
int& bad_foo() {
    int x = 0;
    return x;
}
```

上面这个函数返回了对堆栈上分配的值的引用，当函数返回时，栈帧被释放，那么改引用就失效了。
虽然现代C++编译器和linter会针对类似于上面的简单的case做出一些诊断，但是在更复杂的情况下它们也无能为力。
Rust使用生命周期来保证引用对象的有效性，除非你使用了显示不安全的代码。

### 借用

在Rust中创建引用的过程被称为借用(borrowing)。在Rust中，你只能可变的借用一个可变的值，就像在C++中一样，通常只能创建
一个非常量值的非常量引用。不同的是，在Rust中虽然允许对一个值有多个不可变的借用，但是在同一时刻只能有一个独占的可变借用，
更进一步说，就是当存在一个可变引用的时候，不允许有其他任何引用，无论是可变的还是不可变的。C++中则没有这个限制。

你可能想知道加上这样的限制到底有啥好处。有的人可能会认为这样做更安全，因为当存在可变引用的时候，不允许其他引用存在。这只能算是部分正确：
这种借用行为确实消除了多线程场景中的竟态条件。然而它也使得跨线程的只读访问之外的任何数据共享都变得不可能，当然Rust为我们提供了其他工具
来实现跨线程的non-trivial共享和确保其安全性。

Rust中的借用限制真正做的事情实际上是避免出现任何内存别名(memory aliasing)。当两个指针(或者这里说成引用)指向相同的或者重叠的内存区域时，就会发生内存别名。

### 内存别名(Memory Aliasing)

别名是编译器优化的障碍。对内存的读取和写入操作通常是一个给定函数中最慢的部分，可能存在的别名会迫使编译器比代码作者的预期更加频繁的发出加载指令。

比如这里假设有一个函数，周期性从输入分片读取数据，并执行一些计算后，将结果写入输出分片。
