---
layout: article
title: 'Rust和C+++: 可变性、移动和所有权'
date: 2022-11-01
categories: [programming]
tags: [Rust]
---

## C++和Rust中的不变性(constness)

### 值

Rust和C++有两个相似的概念：Rust中的mutability/immutability和C++中的constness/non-constness.
在Rust中，一个给定的值要么是可变的(mutable)，要么是不可变的(immutable)，正如这些限定符名称所代表的含义，
可变的值可以被修改，不可变的值不能被修改。然而与C++相反的是，Rust中不可变的值可以被移动(move)，就像下面的代码实例那样：

```rust
fn foo() {
    let x = 1;
    println!("{}", x)
    let mut x = x;
    x *= 10;
    println!("{}", x);
}
```

同样的在C++中，给定的值要么是常量(const)，要么是非常量(non-const)。但是C++中的常量值不能被移动(move)。在C++中，对一个const限定符修饰的值
进行`std::move`操作，实际上会触发拷贝构造，这一点在"Effective Modern C++"这本书中作者也有提到：
```cpp
class Annotation {
public:
    explicit Annotation(const std::string text)
     : value(std::move(text)) //here we want to call string(string&&),
                              //but because text is const,
                              //the return type of std::move(text) is const std::string&&
                              //so we actually called string(const string&)
                              //it is a bug which is very hard to find out
    {}
private:
    std::string value;
};
```

我们也可以自己写一段程序来验证一下：

```cpp
#include <iostream>
#include <string>

struct Foo {
  Foo() { std::cout << "default constructor" << std::endl; }
  Foo(const Foo&) { std::cout << "copy constructor" << std::endl; }
  Foo(Foo&&) { std::cout << "move constructor" << std::endl; }
};

int main(int argc, char* argv[]) {
  const Foo foo;
  Foo other = std::move(foo);
  return 0;
}

// 执行结果：
// default constructor
// copy constructor
```

### 引用

引用在C++和Rust中有一些相似。对于这两种语言，引用是一段数据的句柄，它允许程序员在不传递副本的情况下引用该数据。
在这两个语言中，引用都是指针的语法糖。而与指针不同的是，引用或多或少能保证它指向的数据的有效性(至少在创建的时候)。

错误的使用引用是C++中错误的主要来源。而在Rust中提供了更多的安全保证，可以消除大多数这些错误。例如C++并不保证
只要引用存在就一定有效，就像下面这段代码这样：

```cpp
int& bad_foo() {
    int x = 0;
    return x;
}
```

上面这个函数返回了对堆栈上分配的值的引用，当函数返回时，栈帧被释放，那么改引用就失效了。
虽然现代C++编译器和linter会针对类似于上面的简单的case做出一些诊断，但是在更复杂的情况下它们也无能为力。
Rust使用生命周期来保证引用对象的有效性，除非你使用了显示不安全的代码。

### 借用

在Rust中创建引用的过程被称为借用(borrowing)。在Rust中，你只能可变的借用一个可变的值，就像在C++中一样，通常只能创建
一个非常量值的非常量引用。不同的是，在Rust中虽然允许对一个值有多个不可变的借用，但是在同一时刻只能有一个独占的可变借用，
更进一步说，就是当存在一个可变引用的时候，不允许有其他任何引用，无论是可变的还是不可变的。C++中则没有这个限制。

你可能想知道加上这样的限制到底有啥好处。有的人可能会认为这样做更安全，因为当存在可变引用的时候，不允许其他引用存在。这只能算是部分正确：
这种借用行为确实消除了多线程场景中的竟态条件。然而它也使得跨线程的只读访问之外的任何数据共享都变得不可能，当然Rust为我们提供了其他工具
来实现跨线程的non-trivial共享和确保其安全性。

Rust中的借用限制真正做的事情实际上是避免出现任何内存别名(memory aliasing)。当两个指针(或者这里说成引用)指向相同的或者重叠的内存区域时，就会发生内存别名。

### 内存别名(Memory Aliasing)

别名是编译器优化的障碍。对内存的读取和写入操作通常是一个给定函数中最慢的部分，可能存在的别名会迫使编译器比代码作者的预期更加频繁的发出加载指令。

由于Borrow-Checker的强制规则，Rust编译器可以自由的假设不会有内存别名的情况发生。而C++编译器却不能这么做。一些C++编译器有一些flag，用来控制是否开启假设不会出现内存别名，
也有的C++编译器使用关键字(例如`__restrict__`)来注释指针，从而将程序员的假设传达给编译器。但是这些终究只是假设而不是承诺，因此可能会在
无意中被违反，从而产生一些未知的bug或者未定义行为。

下面让我们快速看一个顺序读写的示例，该示例向我们展示了由于内存别名而造成了性能问题。下面两个代码片段是分别用Rust和C++实现了功能相同的函数。
C++版本中使用`#defien`来帮助我们开启编译器的aliasing assumptions开关(`-DDMAYBE_RESTRICT=__restrict__`)。需要特别强调的是，在安全的Rust中调用
src和dst重叠的foo函数是不可能的：

```rust
fn foo(src: &[u32], dst: &mut [u32]) {
    assert_eq!(src.len(), dst.len());
    let mut i = 0;
    while i < src.len() {
        dst[i] = src[i];
        if src[i] % 2 == 0 {
            i += 1;
        } else {
            i += 2;
        }
    }
}
```

```cpp
#ifndef DMAYBE_RESTRICT
#define DMAYBE_RESTRICT
#endif

void foo(const uint32_t* DMAYBE_RESTRICT src, uint32_t* DMAYBE_RESTRICT dst, std::size_t len) {
    std::size_t i = 0;
    while (i < len) {
        dst[i] = src[i];
        if (src[i] % 2 == 0) {
            i += 1;
        } else {
            i += 2;
        }
    }
}
```


在main函数中，我们分配了一个大小为100000000的缓冲区，并填充了测试数据，然后测量调用`foo`所消耗的时间。
当使用`clang++`在开启最高优化等级的时候，使用了`__restrict__`关键字的C++版本和rust版本消耗的时间大致相当。
而不使用`__restrict__`关键字的C++版本则需要多消耗一倍的时间。

那么我们为什么要在一篇讨论constness的文章中来探讨性能呢？与Rust中immutability相对应的constness和关于mutable borrow的Borrow-Checker规则是保证
不会出现内存别名的关键。优点是性能和正确性，但是代价是必须遵守Borrow-Checker的规则。

在C++中实现相同的事情也是可能的，但是你必须将你的假设告诉编译器。如果你想避免出现bug，那就必须由你来确保这些假设的正确性。当然你也可以选择不必和Borrow-Checker对抗。

## C++和Rust中的移动

C++和Rust中的移动语义在概念上类似。不同的是他们如何集成到各自的语言当中的。C++在C++11才引入移动语义，而Rust在诞生之初就集成了move语义。

### C++中的移动

在C++中，移动跟类的特殊成员函数密切相关：构造函数和赋值运算符。构造函数和赋值运算符被重载以接收不同类型的引用。C++根据值的类型来区分不同的引用。
左值引用通常是指对于具名值的引用，并且用一个'&'符号连接；右值引用通常是对表达式计算的临时结果的引用，并且用'&&'符号连接。

{{< alert warning >}}
这里对值类别的总结过于简单，但是对于本文来说足够了。详细完整的描述可以参考: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf
{{< /alert >}}

当我们调用这些特殊的成员函数的时候，重载解析过程会根据引用类型匹配合适的重载函数。我们来看下面这个示例：

```cpp
class S {
public:
    S() {}         // Default Constructor
    S(const S&) {} // Copy Constructor
    S(S&&) {}      // Move Constructor
    S& operator=(const S&) {} // Copy Assignment Operator
    S& operator=(S&&) {}      // Move Assignment Operator
};
```
上面这个类同时具有拷贝构造函数和移动构造函数。当我们尝试使用一个已经存在的引用来构造一个新的`S`的时候，编译器会通过判断
值的类别来决定使用移动构造还是拷贝构造。

如果引用是函数的返回值或者是通过表达式计算出来的，那么该引用是右值引用，此时会使用移动构造。如果我们仅仅是简单的传递了一个具名变量
那么通常这里是左值引用，会使用拷贝构造：

```cpp
void test() {
    S s;
    S s_copied(s); // Copy Constructor
    S s_moved(make_me_an_S_please()); // Move Constructor, passing a result
}
```

那么当我们有一个左值的时候，我们要如何移动呢？答案是使用`std::move`函数。但是这个函数是怎么实现的呢？莫不是使用了什么技巧来移动对象？当然不是！
打开`std::move`的源码我们可以很容易发现这个函数仅仅是做了一个类型转换，其他的什么都没做。它将一个左值引用转换成了一个右值引用:

```cpp
template <class _Tp>
_LIBCPP_NODISCARD_EXT inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename remove_reference<_Tp>::type&&
move(_Tp&& __t) _NOEXCEPT {
    typedef _LIBCPP_NODEBUG typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}
```

但是当我们将`std::move`与构造函数一起使用的时候，就会触发移动构造的调用。

```cpp
void test() {
    S s;
    std::move(s); // This has no effect at all
    S s2;
    s2 = std::move(s); // move s to s2 by Move Assignment Operator
}
```

C++中移动语义经常会给程序员带来麻烦。`std::move`仅仅是将左值引用类型转换成右值引用，然后触发特殊成员函数的右值引用重载版本的调用。
实际上，在C++中移动只是将一个值传递给这些特殊的重载函数之一，这对移动对象的生命周期并没有影响。在上面的例子中，对象`s`并不会因为
被移动了而变得不可用或者超出使用范围，也就意味着我们在移动之后仍然可以自由的使用`s`对象。虽然一些编译器会给出`use-after-move`的
警告，但是这并不能涵盖到所有的场景。

C++移动语义的另一个问题就是，它需要程序员自己来编写移动函数。这就意味着可能会写出有bug的构造函数，此外我们对移动构造和移动赋值的行为也没有达成共识。
人们普遍认为，这些函数应该以一种高效的形式将资源从一个对象转移到另一个对象，而不应该是拷贝。

另一个问题是，当我们在处理被移动的`vector`的时候，如果我们知道这个`vector`再也不会被使用，那么我们可能会简单的什么都不做。没有人会对这个`vector`再做任何改变，但是
我们忽略了一点，这个被移动的`vector`仍然存在，当它超过它的作用域的时候，就会调用析构函数，也就是说，如果我们不清除掉被移动的`vector`中的元素，那么这些元素可能会触发
`double free`。这种情况有一个很容易想到的答案，就是将已经被move的`vector`的状态设置为同默认构造(没有任何空间分配)的`vector`一样的状态，这样就能避免double free的问题，
同时也很容易析构。


