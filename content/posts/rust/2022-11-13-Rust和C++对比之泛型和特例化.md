---
title: "Rust和C++: 泛型和特例化"
date: "2022-11-12"
categories:
  - programming
tags:
  - Rust
---

## 泛型入门：输入的类型

C++和 Rust 中的泛型都是一种将其他类型作为其定义的一部分的类型。泛型是通过在类型定义中指定占位符的一种方式，然后可以
使用更具体的类型来替换，例如在 C++中可以这样写：

```cpp
template<typename T>
struct MyArray {
    T* raw_array;
    std::size_t size;
};
```

如此一来，我们可以说`MyArray<int>`和`MyArray<std::string>`是不同的类型。我们可以通过指定具体的`T`类型，复用`MyArray`这个泛型结构体。
泛型不仅仅局限于结构体，我们同样也能写出泛型函数：

```cpp
template<typename T>
T timestwo(T number) {
    return number + number;
}
```

这里，我们定义了一个非常简单的函数，用来将数值加倍。同样的，`timestwo<int>`和`timestwo<double>`也不是同一个函数。

要在 Rust 中实现上面的函数，可能稍微复杂一点：

```rust
use std::ops::Add;

fn timestwo<T>(number: T) -> <T as Add>::Output
where
    T: Add + Copy,
{
    number + number
}
```

上面 Rust 版本跟 C++版本相比看上去多了很多额外的语法。其中主要的区别是我们调用了特征边界检查，也就是`T: Add + Copy`，
或者用更通俗的话来说，`T`类型必须实现`Add`和`Copy` traits。

### 特征(traits)

Rust 中使用`traits`作为我们在程序中与类型交互的方式。`trait`是与实现`trait`的类型相关联的一组属性、函数或者类型。例如
`Add` 是一个允许执行添加操作的接口。它表示一个类型具有“添加”到其他类型的特征。其定义大致如下：

```rust
pub trait Add<Rhs = Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

上面这个 trait 有两个属性：

1. 关联类型`Output`，用于定义`add`函数的返回类型；
2. `add`函数，将自身添加到`rhs`.

Rust 在编写泛型的时候用下面的方式来定义 traits 的实现，就像一开始我们提供的示例那样：

```rust
use std::ops::Add;

fn timestwo<T>(number: T) -> <T as Add>::Output
where
    T: Add + Copy,
{
    number + number;
}
```

where 语句用于限定，泛型参数`T`必须是实现了`Add`和`Copy` traits 的类型。

## 类型替换(Type Substitution)

我们至此依然没有解释为什么 Rust 的示例比 C++的要冗长的多。现在对 traits 有了一定的了解，我们开始来了解类型替换，主要包含：

1. 什么是类型替换
2. 什么时候触发类型替换
3. 什么情况下的类型替换失败会被视为错误

替换就是将泛型中的`T`占位符填充成实际类型的过程。当我们在 C++中表示`timestwo<int>`的时候，我们将模板类型参数`T`替换成实际类型`int`。
而 C++和 Rust 在泛型中的主要区别体现在上述 2 和 3 方面：什么时候触发类型替换和什么情况下的类型替换失败会被视为错误。

### 替换顺序和失败

在 C++中，替换发生在 `function`/`struct`等最终类型 check 之前。所以在我们前面的例子中，如果我们不引入任何替换，C++基本上不会关心
模板是什么或者我们如何使用模板。例如：

```cpp
#include <iostream>

template<typename T>
T timestwo(T number) {
    return number + number;
}

int main(int argc, char* argv[]) {
    std::cout << "Hello world\n";
}
```

除非模板本身定义有语法问题，否则 C++不会关心`timestwo`是否对所有类型都有意义。直到发生了类型替换，才会做类型检查。所以将一些不相关的类型
插入到`timestwo`函数中可能也不会出现任何问题。

有趣的是，C++有时候也可以替换一些预期之外的类型，例如`std::string`和`std::filesystem::path`都实现了`operator+`操作符，因此这些类型都允许
做加法操作（从技术上来说，这里的`+`是 append 的意思，而不是数字的求和）。这就意味着，`timestwo`对这些类型也有效，即使我们仅仅期望`T`为数字类型。

有时这会导致一些混乱，因为模板适用于不太合适的类型。正如上面的例子中看到的，Rust 中可以通过添加一些特征绑定类避免这种情况。这样我们就只能传递
数字类型。而在 C++中，如果不使用高级特性的话，很难实现这一点。

C++的示例只会在当我们使用一个错不支持`operator+`操作符的类型实例化`timestwo`模板的时候失败。即使其他所有类型对这个模板而言都是错误的，它只需要对于
正在使用这个模板的类型是正确的就行。

```cpp
// Okay, int 支持 '+' 操作符
int a = 2;
int b = timestwo(a);

// Foo 没有实现 '+' 操作符
struct Foo {
    int a;
    float b;
};

Foo c = Foo{1, 2.0};

// 错误不会出现在这里，而是出现在`timestwo`的定义中
// 因为类型检查出现在泛型替换之后
Foo d = timestwo(c);
```

所以只要我们不在模板中使用不支持我们期望的特征的类型，C++编译器就不会有任何错误或异常提示。

与之相对，Rust 采取了截然不同的处理方式。类型检查发生在模板替换之前。这也就是说，我们的泛型必须对任何可以被替换的类型有效，然后才允许我们做模板类型替换。
这也就是为什么 Rust 的示例代码不能像 C++那样写：

```rust
// 会发生编译错误，因为这个模板不适用于所有的类型
fn timestwo<T>(number: T) -> T {
    number + number;
}

fn main() {
    println!("Hello world!");
}
```

如果我们按照上面的方式编写 Rust 代码，那么我们无法保证每一种可能的`T`类型都能够被添加到自身，因我我们无法知道`number + number`是否对所有类型都是合法的。
例如：`timestwo<bool>`就不是合法的，因为`bool`类型在 Rust 中不能做`+`操作。

这也就是 Rust 中使用 traits 的原因——通过在模板类型参数`T`上指定特征边界，我们限定了泛型需要具有的特征范围。所以尽管我们没有在 Rust 中使用`timestwo<string>`，
但是如果`timestwo`的定义没有添加限定条件的话，它一样是非法的。

### 利与弊

## 特例化(Specialization)
