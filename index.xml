<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>liubang's blog</title><link>https://iliubang.cn/</link><description>Recent content on liubang's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2016-2024 LiuBang. All Rights Reserved.</copyright><lastBuildDate>Tue, 23 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://iliubang.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>使用LLVM的libFuzzer进行模糊测试</title><link>https://iliubang.cn/posts/cpp/2023-05-23-%E4%BD%BF%E7%94%A8llvm%E7%9A%84libfuzzer%E8%BF%9B%E8%A1%8C%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</link><pubDate>2023-05-23</pubDate><guid>https://iliubang.cn/posts/cpp/2023-05-23-%E4%BD%BF%E7%94%A8llvm%E7%9A%84libfuzzer%E8%BF%9B%E8%A1%8C%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</guid><description>libFuzzer 简介 LLVM libFuzzer 是 LLVM 生态系统中的一个模糊测试工具，用于自动化地发现软件程序中的漏洞和错误。它通过生成大量的随机输入数据并观察程序的行为来进行模糊测</description></item><item><title>322.零钱兑换</title><link>https://iliubang.cn/leetcode/dp/exercises/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</link><pubDate>2023-04-19</pubDate><guid>https://iliubang.cn/leetcode/dp/exercises/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</guid><description>题目描述 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬</description></item><item><title>70.爬楼梯</title><link>https://iliubang.cn/leetcode/dp/exercises/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</link><pubDate>2023-04-19</pubDate><guid>https://iliubang.cn/leetcode/dp/exercises/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid><description>题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 题解 这道题是一个非常典型而且</description></item><item><title>416.分割等和子集</title><link>https://iliubang.cn/leetcode/dp/exercises/416/</link><pubDate>2023-04-16</pubDate><guid>https://iliubang.cn/leetcode/dp/exercises/416/</guid><description>题目描述 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 题解 由题可知，数组nums非空</description></item><item><title>155.最小栈</title><link>https://iliubang.cn/leetcode/stack/exercises/155/</link><pubDate>2022-12-06</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/155/</guid><description>题目描述 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化 void push(int val) 将元素推入堆栈 void pop() 删除堆栈顶部的元素</description></item><item><title>84. 柱状图中最大的矩形</title><link>https://iliubang.cn/leetcode/stack/exercises/84/</link><pubDate>2022-12-06</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/84/</guid><description>题目描述 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 解法一</description></item><item><title>141.环形链表</title><link>https://iliubang.cn/leetcode/linkedlist/exercises/141/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/linkedlist/exercises/141/</guid><description>题目描述 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中</description></item><item><title>20.有效的括号</title><link>https://iliubang.cn/leetcode/stack/exercises/20/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/20/</guid><description>题目描述 给定一个只包括 &amp;lsquo;(&amp;rsquo;，&amp;rsquo;)&amp;rsquo;，&amp;rsquo;{&amp;rsquo;，&amp;rsquo;}&amp;rs</description></item><item><title>206.反转链表</title><link>https://iliubang.cn/leetcode/linkedlist/exercises/206/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/linkedlist/exercises/206/</guid><description>题目描述 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 解法一：迭代 迭代法应该是我们最容易想到的常规方法，也比较符合人的思维逻辑。其</description></item><item><title>225.用队列实现栈</title><link>https://iliubang.cn/leetcode/queue/exercises/225/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/queue/exercises/225/</guid><description>题目描述 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void</description></item><item><title>232.用栈实现队列</title><link>https://iliubang.cn/leetcode/stack/exercises/232/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/232/</guid><description>题目描述 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元</description></item><item><title>24.两两交换链表中的节点</title><link>https://iliubang.cn/leetcode/linkedlist/exercises/24/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/linkedlist/exercises/24/</guid><description>题目描述 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</description></item><item><title>Rust和C++: 泛型和特例化</title><link>https://iliubang.cn/posts/rust/2022-11-13-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E4%BE%8B%E5%8C%96/</link><pubDate>2022-11-12</pubDate><guid>https://iliubang.cn/posts/rust/2022-11-13-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E4%BE%8B%E5%8C%96/</guid><description>Ref: https://www.tangramvision.com/blog/c-rust-generics-and-specialization 泛型入门：输入的类型 C++和 Rust 中的泛型都是一种将其他类型作为其定义的一部分的类型。泛型是通过在类型定义中指定占位符的一种方式，然后可以 使</description></item><item><title>130.被围绕的区域</title><link>https://iliubang.cn/leetcode/union-find/exercises/130/</link><pubDate>2022-11-07</pubDate><guid>https://iliubang.cn/leetcode/union-find/exercises/130/</guid><description>题目描述 给你一个 m x n 的矩阵 board ，由若干字符 &amp;lsquo;X&amp;rsquo; 和 &amp;lsquo;O&amp;rsquo; ，找到所有被 &amp;lsquo;X&amp;rsquo; 围绕的区域，并将这些区域里所有的 &amp;lsquo;O&amp;rsquo; 用 &amp;lsquo;X&amp;rsquo; 填充。 解法一：并查集 这道题通常会用DFS</description></item><item><title>990.等式方程的可满足性</title><link>https://iliubang.cn/leetcode/union-find/exercises/990/</link><pubDate>2022-11-06</pubDate><guid>https://iliubang.cn/leetcode/union-find/exercises/990/</guid><description>题目描述 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程equations[i]的长度为 4，并采用两种不同的形式之一：&amp;qu</description></item><item><title>128.最长连续序列</title><link>https://iliubang.cn/leetcode/union-find/exercises/128/</link><pubDate>2022-11-05</pubDate><guid>https://iliubang.cn/leetcode/union-find/exercises/128/</guid><description>题目描述 给定一个未排序的整数数nums，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度O(n)的算法</description></item><item><title>Rust和C++: 可变性、移动和所有权</title><link>https://iliubang.cn/posts/rust/2022-11-01-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E5%8F%AF%E5%8F%98%E6%80%A7%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/</link><pubDate>2022-11-01</pubDate><guid>https://iliubang.cn/posts/rust/2022-11-01-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E5%8F%AF%E5%8F%98%E6%80%A7%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/</guid><description>Ref: https://www.tangramvision.com/blog/c-rust-interior-mutability-moving-and-ownership C++和 Rust 中的不变性(constness) 值 Rust 和 C++有两个非常相似的概念，即 Rust 中的 mutability/immutability 和 C++中的 constness/non-constness. 在 Rust 中，一个给定的值要么是可变的(m</description></item><item><title>为什么c++中有了函数指针却还需要std::function</title><link>https://iliubang.cn/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/</link><pubDate>2022-09-28</pubDate><guid>https://iliubang.cn/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/</guid><description>在C/C++中，我们经常会像下面的代码那样使用一个指向函数的指针，我们称之为函数指针： // demo.c #include &amp;lt;stdio.h&amp;gt; int func(int a) { return a + 1; } int main(int argc, char* argv[]) { int (*f)(int) = func; printf(&amp;#34;%p\n&amp;#34;, f); return 0;</description></item><item><title>使用std::list的splice方法实现LRU Cache</title><link>https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/</link><pubDate>2022-05-15</pubDate><guid>https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/</guid><description>std::list splice 简介 splice函数通过重新排列链表指针，将一个std::list中的节点转移到另一个std::list中。在元素的转移过程中不会触发元</description></item><item><title>深入理解 enable_shared_from_this</title><link>https://iliubang.cn/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/</link><pubDate>2022-05-03</pubDate><guid>https://iliubang.cn/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/</guid><description>关于 shared_ptr shared_ptr是一种共享所有权的智能指针，它允许我们安全地访问和管理对象的生命周期。shared_ptr的多个实例通过共享控制块</description></item><item><title>c++ 中 unique_ptr 的一些使用技巧</title><link>https://iliubang.cn/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link><pubDate>2022-04-20</pubDate><guid>https://iliubang.cn/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid><description>前言 c++11 对智能指针做了很大的优化，废弃了 c++98 中的auto_ptr，引入了三种新的智能指针：unique_ptr，shared_ptr，weak_</description></item><item><title>Expression Templates</title><link>https://iliubang.cn/posts/cpp/2022-04-06-expression-templates/</link><pubDate>2022-04-06</pubDate><guid>https://iliubang.cn/posts/cpp/2022-04-06-expression-templates/</guid><description>什么是 Expression Templates Expression Templates 是一种 C++ 模板元编程技术，它通过在编译时构建按需执行的计算表达式，从而生成高效的代码。简单来说，通过 Expression Templates，我们可</description></item><item><title>c++中的动态多态和静态多态</title><link>https://iliubang.cn/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/</link><pubDate>2022-03-23</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/</guid><description>动态多态 (Dynamic Polymorphism) 在 c++中为了实现多态，使用了一种动态绑定的技术，这个技术的核心就是虚函数表(virtual table)。下面就简单的说明一下基</description></item><item><title>c++17:constexpr if</title><link>https://iliubang.cn/posts/cpp/2022-03-18-c++17-constexpr_if/</link><pubDate>2022-03-18</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-18-c++17-constexpr_if/</guid><description>constexpr 是 c++11 引入的关键字，用于编译时常量和常量表达式。而 c++17 将这一特性做了增强，引入了 constexpr if ， 使得编译器在编译时(compile time)能够做分支判</description></item><item><title>c++20:Designated Initializers</title><link>https://iliubang.cn/posts/cpp/2022-03-15-c++20-designated_initializers/</link><pubDate>2022-03-15</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-15-c++20-designated_initializers/</guid><description>对于熟悉 c99 的人来说，Designated Initializers 并不算是什么新鲜事物，然而 c++直到 c++20 才正式支持这一特性。 虽然在 c++20 之前，像 GCC 这样的编译器通过扩展的</description></item><item><title>Linux磁盘IO</title><link>https://iliubang.cn/posts/linux/2022-02-25-linux%E7%A3%81%E7%9B%98io/</link><pubDate>2022-02-25</pubDate><guid>https://iliubang.cn/posts/linux/2022-02-25-linux%E7%A3%81%E7%9B%98io/</guid><description>前言 做存储开发，一定会经常涉及到 IO 相关的操作。而现在的高级编程语言，往往会帮助我们屏蔽 IO 操作的底层细节，虽然这样能降低开发门槛，提升效率，但</description></item><item><title>c++元编程之遍历tuple</title><link>https://iliubang.cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</link><pubDate>2022-02-22</pubDate><guid>https://iliubang.cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</guid><description>对于一个标准的 c++容器来说，我们可以很容易在运行时使用迭代器和 range-based for loop 来遍历其中的每一个元素。但是对于std::tuple，却不能像普通的容</description></item><item><title>c++17:string_view</title><link>https://iliubang.cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</link><pubDate>2022-02-14</pubDate><guid>https://iliubang.cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</guid><description>string_view 简介 std::string_view是 c++17 中新增的一种类型。其核心理念是，能够让我们在传统的 C++03 风格的具体性和泛型编程之间找到一个很好的折衷点</description></item><item><title>LevelDB 源码阅读之 Compaction</title><link>https://iliubang.cn/posts/storage/2021-01-12-leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bcompaction/</link><pubDate>2021-01-12</pubDate><guid>https://iliubang.cn/posts/storage/2021-01-12-leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bcompaction/</guid><description>1. 概览 要谈论 LevelDB 的 Compaction 就不得不从 LevelDB 的整个数据写入流程入手。LevelDB 的基本写入流程大致为： 数据先写入到 WAL 日志中，做持久化 然后数据同步到mut</description></item><item><title>分布式协议</title><link>https://iliubang.cn/posts/inf/2020-05-25-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/</link><pubDate>2020-05-25</pubDate><guid>https://iliubang.cn/posts/inf/2020-05-25-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/</guid><description>拜占庭将军问题 简介 在可能存在叛军的情况下，采用合适的通讯协议，让多个将军达成共识，执行统一的作战计划 二忠一叛难题 它是分布式领域最复杂的容错模</description></item><item><title>使用c语言模拟lisp语法</title><link>https://iliubang.cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</link><pubDate>2019-08-18</pubDate><guid>https://iliubang.cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</guid><description>使用 c 语言的 macro 操作，能够很简单的用 c 语言模拟 lisp 语法。 下面我们来定义 lisp.h 头文件 #ifndef LISP_H_OTE1HWPK #define LISP_H_OTE1HWPK #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define define(ret, name, args, block) \ ret name args { return block; } #define if(expr, block1, block2) \ expr ? block1 : block2 #define eq(a,</description></item><item><title>动态连接器技巧之使用LD_PRELOAD改变程序的行为</title><link>https://iliubang.cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</link><pubDate>2019-07-18</pubDate><guid>https://iliubang.cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</guid><description>我们有这样一段简单的代码，用来输出 10 个[0, 100)的随机数： // random.c #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;time.h&amp;gt; int main() { srand(time(NULL)); int i = 10; while (i--) printf(&amp;#34;%d\n&amp;#34;, rand() % 100); return 0; } 编译运行： liubang@venux-dev:~$ gcc random.c -o random liubang@venux-dev:~$ ./random 44 46</description></item><item><title>多线程编程</title><link>https://iliubang.cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link><pubDate>2018-12-05</pubDate><guid>https://iliubang.cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</guid><description>开始之前 这篇文章主要是为了帮助大家熟悉 POSIX 线程库以及在实际开发中使用它的特性。我们会具体讲解如何利用这个线程库定义的不同工具 来解决编程中的问题</description></item><item><title>使用正则表达式开发一个高性能路由</title><link>https://iliubang.cn/posts/php/2018-04-16-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E8%B7%AF%E7%94%B1/</link><pubDate>2018-04-16</pubDate><guid>https://iliubang.cn/posts/php/2018-04-16-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E8%B7%AF%E7%94%B1/</guid><description>原文地址：http://nikic.github.io/2014/02/18/Fast-request-routing-using-regu</description></item><item><title>c++编程之标准库和STL</title><link>https://iliubang.cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</link><pubDate>2018-03-19</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</guid><description>1. C++标准库 C++提供了很多库： 标准 ANSI C 库都可以移植到 C++中。不同于 ANSI C 库的是，C++中需要在库名前加上&amp;quot;c&amp;quot;前缀，</description></item><item><title>c++编程之字符和字符串</title><link>https://iliubang.cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>2018-03-15</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>1. 字符 1.1 字符类型库：头文件"cctype" 在头文件&amp;lt;cctype&amp;gt;（相当于 C 语言中的&amp;lt;ctype.h&amp;gt;），包含了一下</description></item><item><title>c++编程之操作符重载</title><link>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link><pubDate>2018-03-14</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid><description>操作符重载就是指操作符会对不同类型的操作数表现出不同的行为。例如：(a) 按位左移操作符&amp;rsquo;&amp;laquo;&amp;lsquo;在操作流对象</description></item><item><title>c++编程之模板和泛型编程</title><link>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link><pubDate>2018-03-14</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid><description>1. 简介 我们对传递数值或变量给函数都很熟悉，除了传递变量，我们还能传递类型给模板。传递类型就是大家所熟知的泛型编程，因为 我们可以用泛型编写程序</description></item><item><title>c++编程之继承和多态</title><link>https://iliubang.cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link><pubDate>2018-03-05</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid><description>1. 继承 1.1 术语 超类（基类）和子类（派生类）：在面向对象程序设计中，我们通常使用继承来避免代码冗余。在 C++中，继承的语法规则如下： class SubclassName : inheritance-access-specifier SuperclassName {</description></item><item><title>c++编程之OOP示例</title><link>https://iliubang.cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</link><pubDate>2018-03-02</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</guid><description>1. 示例：使用引用的"Time"类 回到之前版本的&amp;quot;Time&amp;quot;类，假设我们想增加链式操作，例如t.nextSecond().</description></item><item><title>c++编程之指针，引用和内存动态分配</title><link>https://iliubang.cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</link><pubDate>2018-02-23</pubDate><guid>https://iliubang.cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</guid><description>指针，引用和动态分配内存是 C/C++语言中最强大的特性，这些特性使得程序员能够直接操作计算机中非常珍贵的记忆体资源，进而对内存进行最大性能和</description></item><item><title>c++编程之面向对象</title><link>https://iliubang.cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>2018-02-13</pubDate><guid>https://iliubang.cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>1. 为什么要使用 OOP？ 假如你想组装一台电脑，你会去硬件商店购买主板、处理器、内存条、硬盘、机箱、电源，然后将它们组装在一起，然后打开电源，电</description></item><item><title>PHP7虚拟机</title><link>https://iliubang.cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>2017-11-29</pubDate><guid>https://iliubang.cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html 写这篇文章的</description></item><item><title>PHP和线程</title><link>https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>2017-10-12</pubDate><guid>https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</guid><description>原文地址http://blog.jpauli.tech/2017/01/12/threads-and-php.html 前言 PHP 和线程，单凭这简</description></item><item><title>理解c语言中的声明</title><link>https://iliubang.cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</link><pubDate>2017-09-12</pubDate><guid>https://iliubang.cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</guid><description>在阅读优秀的 c 语言开源程式的时候，我们经常会看到各种复杂的声明，顿时会让我们怀疑人生，怀疑自己是否真的看得懂 c 语言。然而冷静三秒钟，透过现象</description></item><item><title>PHP扩展开发之迭代器</title><link>https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>2017-08-28</pubDate><guid>https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>preface 在之前的文章中，我们已经实现了一些 object handlers 来将我们的 ArrayBuffer 整合到 php 中。但是美中不足的是，我们的 ArrayBufferView 并不支持迭代器操作。也就是它不能像 php 中的数组那样使</description></item><item><title>PHP扩展开发之对象处理器(Object Handlers)</title><link>https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>2017-08-27</pubDate><guid>https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</guid><description>Object Handlers 在前面的博文中，已经介绍过一些 object handlers 了，也特别介绍了如何通过指定 handlers 来创建一个自定义的结构和使用clone_obj来对自定义的结构进行克隆操</description></item><item><title>PHP扩展开发之打造一个简易的ArrayBuffer</title><link>https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</link><pubDate>2017-08-25</pubDate><guid>https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</guid><description>ArrayBuffer 简介 ArrayBuffer 又叫二进制数组，是一个用来表示通用的，固定长度的二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容， 而是创建一个表示特定格式的 buffer 的类型化数组对</description></item><item><title>PHP扩展开发之自定义对象的存储</title><link>https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</link><pubDate>2017-08-24</pubDate><guid>https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</guid><description>前言 对于 php 扩展开发，很多人可能已经不那么陌生了，zend 引擎为了们提供了非常丰富了函数和 macro，来帮助我们很快速的创建一个标准的 php 类，然</description></item><item><title>数据结构之hashtable</title><link>https://iliubang.cn/posts/ds/2017-08-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bhashtable/</link><pubDate>2017-08-22</pubDate><guid>https://iliubang.cn/posts/ds/2017-08-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bhashtable/</guid><description>hashtable 哈希表又叫散列表，是实现字典操作的中有效数据结构。通常来说，一个 hash table 包含了一个数据，其中的数据通过 index 来访问。 而 hash table 的基本原理就是通过 hash 函数</description></item><item><title>c语言之struct</title><link>https://iliubang.cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</link><pubDate>2017-08-21</pubDate><guid>https://iliubang.cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</guid><description>struct 在 c 语言中，结构体(struct)是一种复合数据类型，用来将一系列相同或不同类型的变量聚集在同一个内存区间内并赋予同一个名字，使得通过一个</description></item><item><title>Java Native Interface（二）</title><link>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%BA%8C/</link><pubDate>2017-03-20</pubDate><guid>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%BA%8C/</guid><description>1、JNI 基础 JNI 中定义了一下类型来对应到相应的 Java 的数据类型: 1. Java 基本数据类型: jint,jbyte,jshort,jlong,jfloat,</description></item><item><title>Java Native Interface（三）</title><link>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%B8%89/</link><pubDate>2017-03-20</pubDate><guid>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%B8%89/</guid><description>前面系统研究了 JNI 的相关操作，下面就来小试牛刀，做一个实际的练习。 记得去年我曾经用 C 语言写过一个 PHP 的 md5 扩展函数，那么今天就花一点点时间用 JNI 来实</description></item><item><title>Java Native Interface（一）</title><link>https://iliubang.cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/</link><pubDate>2017-03-17</pubDate><guid>https://iliubang.cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/</guid><description>最近在整理学习笔记的时候发现了去年年中记录的 JNI 学习笔记，由于存放在了为知笔记中，而如今为知笔记已经不再免费，于是想到了将其重新整理一遍，一来</description></item><item><title>彻底掌握malloc</title><link>https://iliubang.cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</link><pubDate>2017-03-17</pubDate><guid>https://iliubang.cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</guid><description>说明：参考文献地址 A Malloc Tutorial 1 简介 malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一个</description></item><item><title>基于c语言的编程语言开发</title><link>https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</link><pubDate>2017-03-15</pubDate><guid>https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</guid><description>Preface 当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问&amp;ndash;计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可</description></item><item><title>PHP扩展开发之call_user_func原理和回调函数的实现</title><link>https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>2017-03-09</pubDate><guid>https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>函数调用 很多时候，我们需要通过函数名来调用函数，并传递参数，或者把匿名函数作为函数的参数传递，实现回调。当我们在遇到这样的需求的时候，用 php 代</description></item><item><title>关于</title><link>https://iliubang.cn/about/</link><pubDate>2017-01-01</pubDate><guid>https://iliubang.cn/about/</guid><description/></item><item><title>Offline</title><link>https://iliubang.cn/offline/</link><pubDate>0001-01-01</pubDate><guid>https://iliubang.cn/offline/</guid><description/></item></channel></rss>