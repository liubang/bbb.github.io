<!doctype html><html class=position-relative itemscope itemtype=http://schema.org/WebPage lang=zh-cn data-bs-theme=auto data-palette=blue-gray><head><script src=https://iliubang.cn/assets/init/bundle.min.4e1c6ffabb6999cbb3606909003fd1dacb91d95e0da37cd4431e72cc357abbce.js integrity="sha256-Thxv+rtpmcuzYGkJAD/R2suR2V4No3zUQx5yzDV6u84=" crossorigin=anonymous></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>彻底掌握malloc - liubang's blog</title><link rel=icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_16x16_resize_box_3.png sizes=16x16 type=image/png><link rel=icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_32x32_resize_box_3.png sizes=32x32 type=image/png><link rel=apple-touch-icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_180x180_resize_box_3.png sizes=180x180 type=image/png><link rel=icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_150x150_resize_box_3.png sizes=150x150 type=image/png><link rel=icon href="https://iliubang.cn/images/icons/icon-192x192.png?version=5675e36f11a529bcbecb4e1fae90c416" sizes=192x192><link rel=mask-icon href=https://iliubang.cn/safari-pinned-tab.svg color=#6f42c1><link rel=icon href="https://iliubang.cn/images/icons/favicon.ico?version=93c96d13551a46e5742ae6da86026661"><meta name=keywords content><meta name=description content="说明：参考文献地址 A Malloc Tutorial 1 简介# malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一"><meta name=robots content="index, follow"><meta name=twitter:card content="summary"><meta name=twitter:title content="彻底掌握malloc"><meta name=twitter:description content="说明：参考文献地址 A Malloc Tutorial 1 简介# malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一"><meta property="og:title" content="彻底掌握malloc"><meta property="og:description" content="说明：参考文献地址 A Malloc Tutorial 1 简介# malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一"><meta property="og:type" content="article"><meta property="og:url" content="https://iliubang.cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-03-17T00:00:00+00:00"><meta property="article:modified_time" content="2017-03-17T00:00:00+00:00"><meta itemprop=name content="彻底掌握malloc"><meta itemprop=description content="说明：参考文献地址 A Malloc Tutorial 1 简介# malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一"><meta itemprop=datePublished content="2017-03-17T00:00:00+00:00"><meta itemprop=dateModified content="2017-03-17T00:00:00+00:00"><meta itemprop=wordCount content="9076"><meta itemprop=keywords content="c,sp,"><meta property="og:image" content="https://iliubang.cn/images/apple-touch-icon.png"><meta name=twitter:image content="https://iliubang.cn/images/apple-touch-icon.png"><link rel=manifest href=https://iliubang.cn/manifest.json><link data-precache rel=stylesheet href="https://iliubang.cn/assets/main/bundle.min.029b1d3ae0a7a37a7bcb6b545b165af5a6890eceef8df960c437942dac3078f7.css" integrity="sha256-ApsdOuCno3p7y2tUWxZa9aaJDs7vjflgxDeULawwePc=" crossorigin=anonymous><link data-precache rel=stylesheet href=https://iliubang.cn/assets/katex/bundle.min.222aac0b0b2e29944e5e468ecbd302b4ece09ac5ee29a0c811086b03659edd76.css integrity="sha256-IiqsCwsuKZROXkaOy9MCtOzgmsXuKaDIEQhrA2We3XY=" crossorigin=anonymous><link data-precache rel=stylesheet href=https://iliubang.cn/assets/viewer/bundle.min.6d0fc65b8b058ac563091dc5c36f61afba5dd705058680aa24f1d5a3bcf0064d.css integrity="sha256-bQ/GW4sFisVjCR3Fw29hr7pd1wUFhoCqJPHVo7zwBk0=" crossorigin=anonymous></head><body><header><nav class="top-app-bar shadow navbar navbar-expand-lg fixed-top"><div class=container><a class="navbar-brand d-flex align-items-center flex-grow-1 flex-lg-grow-0 text-lg-start ms-2 ms-lg-0 mx-auto me-lg-2" href=https://iliubang.cn><picture><img class=logo alt=Logo src=https://iliubang.cn/images/apple-touch-icon.png loading=lazy width=180 height=180>
</picture>HIGHKYCK</a>
<button class="navbar-toggler order-5" type=button data-bs-toggle=offcanvas data-bs-target=#navbarMenus aria-controls=navbarMenus aria-expanded=false aria-label="Toggle navigation">
<i class="fas fa-ellipsis-h"></i></button><div class="offcanvas-lg offcanvas-end flex-grow-1" data-bs-scroll=true tabindex=-1 id=navbarMenus aria-labelledby=navbarMenusLabel><div class="offcanvas-header px-4 pb-0"><h5 class=offcanvas-title id=navbarMenusLabel>liubang's blog</h5><button type=button class="btn-close btn-close-white" data-bs-dismiss=offcanvas data-bs-target=#navbarMenus aria-label=Close></button></div><div class="offcanvas-body p-4 pt-0 p-lg-0"><hr class=d-lg-none><ul class="navbar-nav flex-row flex-wrap align-items-center me-auto"><li class="nav-item col-6 col-lg-auto"><a class="nav-link py-2 px-0 px-lg-2" href=https://iliubang.cn/archives/><i class="fas fa-fw fa-file-archive"></i>归档</a></li><li class="nav-item col-12 col-lg-auto dropdown px-0"><a href=# class="nav-link dropdown-toggle" id=navbarDropdownCategories role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-folder"></i>分类</a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=navbarDropdownCategories data-bs-popper=none><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/categories/programming><i class="fas fa-fw fa-code me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">Programing</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/categories/reading><i class="fas fa-fw fa-book-reader me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">Reading</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/categories/linux><i class="fab fa-fw fa-linux me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">Linux</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/categories><i class="fas fa-fw fa-folder me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">所有分类</p></div></a></li></ul></li><li class="nav-item col-12 col-lg-auto dropdown px-0"><a href=# class="nav-link dropdown-toggle" id=navbarDropdownTags role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-tags me-1"></i>标签</a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=navbarDropdownTags data-bs-popper=none><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/algorithm><i class="fas fa-fw fa-square-root-alt me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">Algorithm</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/c++><i class="fab fa-fw fa-google me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">C++</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/go><i class="fab fa-fw fa-google me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">Go</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/java><i class="fab fa-fw fa-java me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">Java</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/storage><i class="fas fa-fw fa-database me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">Storage</p></div></a></li><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/tags><i class="fas fa-fw fa-tags me-1"></i><div class=dropdown-item-content><p class="dropdown-item-title mb-0">所有标签</p></div></a></li></ul></li><li class="nav-item col-12 col-lg-auto dropdown px-0"><a href=# class="nav-link dropdown-toggle" id=navbarDropdownSeries role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-columns me-1"></i>专栏</a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=navbarDropdownSeries data-bs-popper=none><li><a class="dropdown-item d-flex align-items-center text-wrap text-lg-nowrap" href=https://iliubang.cn/leetcode/><div class=dropdown-item-content><p class="dropdown-item-title mb-0">LeetCode</p></div></a></li></ul></li></ul><hr class=d-lg-none><form class="search-bar ms-auto my-1" action=https://iliubang.cn/search/ novalidate><div class="input-group input-group-sm align-items-center"><span class="btn btn-search disabled position-absolute left-0 border-0"><i class="fas fa-fw fa-search fa-lg"></i></span>
<input class="py-2 form-control rounded search-input" name=q type=search aria-label=Search required></div></form><hr class=d-lg-none><ul class="navbar-nav flex-row flex-wrap align-items-center ms-md-auto"><li class="nav-item py-2 py-lg-1 col-12 col-lg-auto"><nav class="social-links nav justify-content-center flex-row"><a class="nav-link social-link col-6 col-lg-auto p-1" target=_blank href=https://github.com/liubang title=GitHub rel=me><i class="fa-fw fab fa-github"></i>
<span class="ms-1 d-lg-none">Github</span></a>
<a class="nav-link social-link col-6 col-lg-auto p-1" target=_blank href=https://iliubang.cn/index.xml title=RSS rel=me><i class="fas fa-fw fa-rss"></i>
<span class="ms-1 d-lg-none">RSS</span></a></nav></li><li class="nav-item py-2 py-lg-1 col-12 col-lg-auto"><div class="vr d-none d-lg-flex h-100 mx-lg-2 text-white"></div><hr class="d-lg-none my-2"></li><li class="nav-item dropdown py-1 py-lg-1 col-6 col-lg-auto"><a class="nav-link px-0 px-lg-1" href=# id=languageDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-globe"></i>
<span class=d-lg-none>语言</span></a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=languageDropdown><li><a class=dropdown-item href=https://iliubang.cn/en/>English</a></li><li><a class="dropdown-item active" href=https://iliubang.cn/>简体中文</a></li></ul></li><li class="nav-item py-1 col-12 col-lg-auto"><div class="vr d-none d-lg-flex h-100 mx-lg-2 text-white"></div><hr class="d-lg-none my-2"></li><li class="nav-item dropdown col-6 col-lg-auto"><a class="nav-link px-0 py-2 px-lg-1" href=# id=modeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="mode-icon fas fa-fw fa-adjust" id=modeIcon></i>
<span class=d-lg-none>模式</span></a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=modeDropdown><li class=mode-item data-color-mode=light data-icon=sun><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-sun"></i> Light</button></li><li class=mode-item data-color-mode=dark data-icon=moon><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-moon"></i> Dark</button></li><li class="mode-item active" data-color-mode=auto data-icon=adjust><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-adjust"></i> Auto</button></li></ul></li></ul></div></div></div></nav></header><main class=container><div class="row content"><noscript><div class="alert alert-danger" role=alert>你的浏览器不支持 JavaScript。</div></noscript><div class=col-lg-8><div class=container><nav class="row card component" aria-label=breadcrumb><div class="card-body pb-0"><ol class=breadcrumb><li class="breadcrumb-item text-surface"><a href=https://iliubang.cn/>主页</a></li><li class="breadcrumb-item text-surface"><a href=https://iliubang.cn/posts/>文章</a></li><li class="breadcrumb-item active">彻底掌握malloc</li></ol></div></nav><div class="post-panel-wrapper position-sticky"><div class="d-flex flex-column component rounded post-panel position-absolute border"><a class="action action-panel-toggler" role=button title="Panel toggler"><i class="fas fa-fw fa-chevron-circle-down"></i></a>
<a id=sidebarToggler class="action action-sidebar-toggler d-none d-lg-block" role=button title="Sidebar toggler"><i class="fas fa-fw fa-expand-alt" data-fa-transform=rotate-45></i></a>
<a class="action btn-reward" role=button data-bs-toggle=modal data-bs-target=#rewardModal title=打赏><i class="fas fa-fw fa-coffee"></i></a>
<a class="action action-toc" href=#postTOC aria-controls="Table of contents" role=button title="Table of contents"><i class="fas fa-fw fa-list-alt"></i></a>
<a class="action action-copyright" href=#post-copyright role=button aria-label=Copyright title=Copyright><i class="fas fa-fw fa-copyright"></i></a>
<a class="action action-post-comments" href=#post-comments role=button aria-label=Comments title=Comments><i class="fas fa-fw fa-comments"></i></a></div></div><article class="row card component mb-4 post"><div class=card-header><h1 class="card-title post-title my-2">彻底掌握malloc</h1></div><div class=card-body><div class="post-meta mb-3"><span class="post-date me-1 mb-1" title="创建于 2017-03-17 00:00:00 +0000 UTC。">2017-03-17</span><span class="post-reading-time me-1 mb-1">19 分钟阅读</span><a href=https://iliubang.cn/categories/programming/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-category">
<i class="fas fa-fw fa-folder me-1"></i>Programming</a><a href=https://iliubang.cn/tags/c/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">C</a><a href=https://iliubang.cn/tags/sp/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">Sp</a></div><div id=postTOC class="mt-2 mb-4 d-block d-lg-none"><h2 class="text-surface mb-3">目录</h2><div id=post-toc-container></div></div><div class="post-content mb-3" data-bs-spy=scroll data-bs-target=#TableOfContents tabindex=0><div id=post-content-body><p>说明：参考文献地址 <a href=http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf target=_blank rel="noopener noreferrer">A Malloc Tutorial<i class="fas fa-external-link-square-alt ms-1"></i></a></p><h2 id=1-简介 data-numberify>1 简介<a class="anchor ms-1 d-none" href=#1-简介>#</a></h2><p><code>malloc</code>是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一个程序员而言，<code>malloc</code>是一个在 c 语言中用来分配内存的函数，但是大多数人并不知道它背后真正的原理，甚至有些人认为<code>malloc</code>是 c 语言的关键字或者认为它是系统调用。事实上，<code>malloc</code>是一个再简单不过的函数而已，而且只需要很少的操作系统相关知识就可以让我们彻底理解它的原理。</p><p>下面来一步步的实现一个简单的<code>malloc</code>函数，从而帮助我们理解其背后运作的原理。因为仅仅作为说明原理之用，所以这里实现的<code>malloc</code>不会太高效，但是足以说明原理。</p><p>什么是 malloc</p><p><code>malloc(3)</code>是一个用来分配内存块的标准的 c 语言库函数。它遵循以下规则：</p><ul><li><code>malloc</code>至少分配所需字节数的内存；</li><li><code>malloc</code>返回其所分配内存空间(程序可以成功读写的空间)的指针；</li><li>一块内存一旦被<code>malloc</code>分配，其他<code>malloc</code>调用不能再分配该内存块的任何部分，除非指向该内存块的指针被释放掉；</li><li><code>malloc</code>应该是可控的：他必须能够很快完成分配并返回；</li><li><code>malloc</code>同时应该提供重新分配内存块大小和释放内存的功能</li></ul><p><code>malloc</code>函数必须遵循以下原型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>malloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>);</span>
</span></span></code></pre></div><p>其中<code>size</code>是所需要的内存大小。如果失败（没有足够的内存空间可以分配），应该返回<code>NULL</code>。</p><h2 id=2-堆brk-和-sbrk-系统调用 data-numberify>2 堆，brk 和 sbrk 系统调用<a class="anchor ms-1 d-none" href=#2-堆brk-和-sbrk-系统调用>#</a></h2><p>在开始实现第一个<code>malloc</code>函数之前，需要了解内存在大多数多任务操作系统中是如何管理的。这里我们只是做出一个抽象的解释，从大体上去帮助理解，至于很多细节，它们都依赖操作系统原理和硬件相关的知识。</p><h3 id=21-进程的内存 data-numberify>2.1 进程的内存<a class="anchor ms-1 d-none" href=#21-进程的内存>#</a></h3><p>每个进程都有自己的虚拟地址空间被 MMU（Memory Management Unit, 内存管理单元）(和内核)动态的转换到物理内存地址空间。这部分空间被划分成了几个部分，我们需要了解的是至少有一部分空间存放代码，一个用来存放局部变量的栈，一部分用来存放常量和全局变量的空间，以及程序的无组织空间我们称之为堆。</p><p>堆是一个连续的（依据虚拟地址而言）内存空间，它有三个边界：一个起始点，一个最大限度边界（通过 sys/ressource.h 中的 getrlimit(2)函数和 setrlimit(2)函数来管理）和一个被称为<code>break</code>的结束点。<code>break</code>标记了隐射内存空间的结束，也就是说，虚拟地址空间部分对应着真实的内存空间。下图表示内存组织结构</p><p><picture><img class="img-fluid mx-auto d-block" alt=heap src=https://iliubang.cn/images/2017-03-17/heap.png loading=lazy width=512 height=114></picture></p><p>要想实现一个<code>malloc</code>函数，我们需要知道堆的起始点和 break 的位置，然后我们来移动 break。要做到这些，就需要用到两个系统调用，<code>brk</code>和<code>sbrk</code>。</p><h3 id=22-brk2和-sbrk2 data-numberify>2.2 brk(2)和 sbrk(2)<a class="anchor ms-1 d-none" href=#22-brk2和-sbrk2>#</a></h3><p>我们可以在这些系统调用的文档中看到相关描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span>     <span class=nf>brk</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>    <span class=o>*</span><span class=nf>sbrk</span><span class=p>(</span><span class=kt>intptr_t</span> <span class=n>incr</span><span class=p>);</span>
</span></span></code></pre></div><p>在 linux 系统中使用<code>man 2 brk</code>命令查看文档</p><blockquote><p>brk() and sbrk() change the location of the program break, which defines the end of the process&rsquo;s data segment (i.e., the program break is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory.
brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size (see setrlimit(2)).
sbrk() increments the program&rsquo;s data space by increment bytes. Calling sbrk() with an increment of 0 can be used to find the current location of the program break.
On success, brk() returns zero. On error, -1 is returned, and errno is set to ENOMEM.
On success, sbrk() returns the previous program break. (If the break was increased, then this value is a pointer to the start of the newly allo‐cated memory). On error, (void *) -1 is returned, and errno is set to ENOMEM.</p></blockquote><p>我们将使用<code>sbrk</code>作为主要工具来实现一个<code>malloc</code>函数。所要做的事情就是获取更多的空间(如果需要的话)去满足调用者的需求。</p><h3 id=23-unmapped-region-and-no-mans-land data-numberify>2.3 Unmapped Region and No-Man&rsquo;s Land<a class="anchor ms-1 d-none" href=#23-unmapped-region-and-no-mans-land>#</a></h3><p>正如前面讲到的 break 标记了映射虚拟地址空间的结束：越过 break 来访问地址会造成总线错误。maximum limit 和 break 之间的剩余地址没有被系统的虚拟内存管理器关联到物理内存。
但是，如果你了解一点关于虚拟内存的知识，那么你会知道内存是通过 page 来映射的：物理内存和虚拟内存是组织在具有固定大小的 page 中(大多数情况下)。page 的大小圆圆超过 1byte(在大多数操作系统中，page size 是 4096bytes)。也就是说，break 有可能没有恰好落在 pages 的边界上。</p><p><picture><img class="img-fluid mx-auto d-block" alt=heap1 src=https://iliubang.cn/images/2017-03-17/heap1.png loading=lazy width=512 height=118></picture></p><p>上图展示了带有 page 边界的内存组织结构。我们可以看到 break 没有对齐到 page 的边界。那么处于 break 和下一个 page 边界之间的内存是一种什么样的状态呢？事实上，这段空间是可以访问的！你可以在这段空间里读写字节。问题是，你对下一个 page 边界的位置没有任何线索，你可以依赖操作系统来找到它，但是这是一个不好的建议。</p><p>这些 no-man&rsquo;s land 通常是 bug 的根源：一些对堆外指针的错误操作大多数只有小测试的情况下都能成功，只有当操作很大量的数据的时候会失败。</p><h3 id=24-mmap2 data-numberify>2.4 mmap(2)<a class="anchor ms-1 d-none" href=#24-mmap2>#</a></h3><p>尽管我们在本文中不会用到<code>mmap(2)</code>系统调用，但是我们仍然需要花时间去了解它。它有一个匿名模式(mmap(2)通常被用来直接的在内存中映射文件)可以用来(完整地或者在某些特殊情况下)实现<code>malloc</code>函数。</p><p><code>mmap(2)</code>在匿名模式下可以分配特定的记忆体空间，而<code>munmap</code>可以将其释放。这通常比传统的基于<code>sbrk</code>的 malloc 要更简单和高效。一些 malloc 实现使用<code>mmp</code>来分配较大的空间(超过一个 page)。OpenBSD 的 malloc 函数只使用<code>mmap</code>，加上一些方法以提高安全性。</p><h2 id=3-实现一个简陋的-malloc data-numberify>3 实现一个简陋的 malloc<a class="anchor ms-1 d-none" href=#3-实现一个简陋的-malloc>#</a></h2><p>首先，我们将要使用<code>sbrk(2)</code>来实现一个简陋的 malloc。这个 malloc 可能是最烂的一个，但是也是最简单，实现起来最快的一个。</p><h3 id=31-原理 data-numberify>3.1 原理<a class="anchor ms-1 d-none" href=#31-原理>#</a></h3><p>原理非常的简单，每当<code>malloc</code>被调用的时候，我们将 break 移动所需字节的空间，然后返回异动前 break 的地址。看起来是不是很简单，这样只需要 3 行代码就可以实现，但是这样的话我们无法实现释放和重新分配的功能。</p><h3 id=32-实现 data-numberify>3.2 实现<a class="anchor ms-1 d-none" href=#32-实现>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>malloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sbrk</span><span class=p>(</span><span class=n>size</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=4-堆 data-numberify>4 堆<a class="anchor ms-1 d-none" href=#4-堆>#</a></h2><p>在上一节中，我们花了点时间实现了一个简单的 malloc 函数，但是并不能满足所有的需求。因此本节我们将尝试着去了解堆从而实现一个更加高效的 malloc 函数，进而实现 free 和 realloc。</p><h3 id=41-我们需要什么 data-numberify>4.1 我们需要什么<a class="anchor ms-1 d-none" href=#41-我们需要什么>#</a></h3><p>如果我们考虑编程环境之外的问题，我们可以推断出什么样的信息能解决我们的问题。让我们来做个比喻：你拥有一块区域，然后划分它其中的一部分租出去。客户要求不同的尺寸(你划分的时候都是按照同一个的标准)而且还要是连续的。当他们使用完了退回给你，然后你又可以接着租出去。</p><p>在这片领域的一边有一条路，路上有一辆可以编程的车：你可以输入区域和目的地之间的距离。我们需要知道每一块是从哪里开始的（这就相当于 malloc 返回的指针）。</p><p>一个解决方案是我们标记每一个下一部分开始的地址（和当前部分的大小以避免不必要的计算）。我们也将空闲的部分打上标记（当客户使用完返还的时候做上标记）。此时，当有客户想要一个确定大小的区域的时候我们坐车遍历一个个标记。当我们发现一个区域被标记为空闲状态而且能够满足客户的需求的时候，我们去掉空闲的标记然后租给客户。如果我们到了最后一个区域（这个区域的标记没有指向下一个区域的地址）我们只需要到这个区域的末尾添加一个新的标记。</p><p>我们可以把上述的思想转换到内存中：在每一个内存块的开始部分需要有额外的信息，其中包括内存区块的大小，下一个区块的地址和当前区块是否为空闲状态。</p><h3 id=42-如何表示块信息 data-numberify>4.2 如何表示块信息<a class="anchor ms-1 d-none" href=#42-如何表示块信息>#</a></h3><p>我们需要的仅仅是在每一个 chunk 的开始需要有一个很小的 block 来保存额外的信息，这个信息被称为 meta-data。这个 block 至少需要包含一个指向下一 chunk 的指针，一个标记当前 chunk 是否为 free 的标记以及当前 chunk 的可存放的 data size。当然，这个 block 在 malloc 函数返回的指针前面。</p><p><picture><img class="img-fluid mx-auto d-block" alt=chunk src=https://iliubang.cn/images/2017-03-17/chunk.png loading=lazy width=503 height=248></picture></p><div style=text-align:center>Heap's Chunks Structure</div><p>上图展示了一种分配的 block 前带有 meta-data 信息的堆的组织结构。每一个 chunk 都包含一个存放 meta-data 的 block 和一个存放数据的 block。malloc 函数返回的指针指向的是存放数据的 block，而不是整个 chunk。</p><p>那么，我们该如何把它转换成 c 代码呢？上述思想看起来很像一个传统的链表，于是我们写了一个链表：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>s_block</span> <span class=o>*</span><span class=n>t_block</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>s_block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>  <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=n>free</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>说明：使用<code>typedef</code>可以简化自定义类型的使用。考虑到我们使用该类型的时候都是基于指针的形式，所以在<code>typedef</code>中将<code>s_block</code>定义为<code>t_block</code>类型的指针，这对链表来说会是一个很好的体验，因为链表是一个指针，而不是一个 block（一个空链表就是一个空指针）。</p><p>将 flag 设置成 int 类型看起来很浪费空间，但是由于结构体是默认对齐的，所以改变 flag 的类型对结构体占用空间没有任何影响。待会我们会看到我们将如何来压缩 meta-data 的 size。此外还需要注意的一点就是 malloc 必须返回对齐的地址。</p><p>一个被问的很频繁的问题是：在没有 malloc 的情况下我们如何创建一个结构体？The answer is simple.你只需要知道一个结构体到底是什么就好了。在内存中，一个 struct 仅仅是其字段的串联，所以在上述例子中，struct <code>s_block</code>只是 12bytes(32 bit integer)，第一个 4bytes 指的是<code>size</code>这个字段，第二个 4bytes 指的是<code>next</code>这个字段，最后一个指的是<code>free</code>这个字段。当编译器遇到访问 struct 字段(例如 s.free 或 p->free)的情况时，它会将其转换成 struct 的基地址加上它前面字段的长度(p->free ==> _((char _)p+8), s.free ==> _((char _)&s + 8))。你需要做的就是用<code>sbrk</code>分配足够的空间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Example of using t_block without malloc */</span>
</span></span><span class=line><span class=cl><span class=n>t_block</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* save ths old break in b */</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* add the needed space */</span>
</span></span><span class=line><span class=cl><span class=cm>/* size is the parameter of malloc */</span>
</span></span><span class=line><span class=cl><span class=nf>sbrk</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>s_block</span><span class=p>)</span> <span class=o>+</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=5-malloc-的第一个优化版 data-numberify>5 malloc 的第一个优化版<a class="anchor ms-1 d-none" href=#5-malloc-的第一个优化版>#</a></h2><p>在这一节当中我们将实现第一个传统 mallc 的优化版。第一个优化算法非常简单：我们遍历 chunks 列表直到我们发现一个 free 的 block 而且有足够的空间来满足需求。</p><h3 id=51-指针对齐 data-numberify>5.1 指针对齐<a class="anchor ms-1 d-none" href=#51-指针对齐>#</a></h3><p>指针常常需要按照整型来对齐。这里我们只考虑 32bit 的情况，64bit 原理相同。因此，指针必须能被 4(32 bits = 4 bytes)整除。meta-data block 已经对齐了，那么我们唯一需要做的事情就是使得 data 的 size 对齐。</p><p>首先，我们来玩玩数字游戏：任取一个正整数，先整除 4，然后再乘以 4，这样就得到了最近的一个能被 4 整除的且比 4 小的数字，如果要得到最近的一个能被 4 整除且大于 4 的数字就再加上一个 4。</p><p>任取一个正整数$x$，</p><p>\[
x = 4 \times p + q, q \in \left[0, 3\right]
\]</p><p>如果$x$是 4 的倍数，那么</p><p>\[
q = 0, x - 1 = 4 \times \left(p - 1\right) + 3, \left(\left(x - 1\right) / 4 \right) \times 4 + 4 = 4 \times p = x
\]</p><p>如果$x$不是 4 的倍数，那么</p><p>\[
q \not= 0, x - 1 = 4 \times p + \left(q - 1\right), q - 1 \in \left[0, 2\right];
\]</p><p>所以：</p><p>\[
\left(x - 1\right)/4\times4+4 = 4 \times p + p = x/4\times4+4
\]</p><p>于是我们得到了一个公式:</p><p>\[
\left(x - 1\right) / 4 \times4 + 4
\]</p><p>那么，我们怎样用 c 语言来表示呢？首先，跟 4 做乘法和除法可以被表示成左位移和右位移运算(&#171;和&#187;)，它比普通的运算要高效很多。因此我们的公式在 c 语言中可以写成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>((</span><span class=n>x</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=o>&gt;&gt;</span><span class=mi>2</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>4</span>
</span></span></code></pre></div><p>要想得到一个正确的宏，我们需要添加一些额外的括号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define align4(x)   (((((x)-1)&gt;&gt;2)&lt;&lt;2)+4)
</span></span></span></code></pre></div><h3 id=52-查找-chunk第一个优化算法 data-numberify>5.2 查找 chunk:第一个优化算法<a class="anchor ms-1 d-none" href=#52-查找-chunk第一个优化算法>#</a></h3><p>查找一个标记为 free 的且又空间富裕的 chunk 是如此的简单：我们开始在堆的基址(程序中会保存，待会我们会看到)检验当前的 chunk，如果它能满足需求，我们只需要返回它的地址即可，否则我们继续下一个 chunk 直到我们找到了满足需求的 chunk，或者到了堆末尾也没找到。唯一的技巧就是保存最后一次访问的 chunck，因此如果我们没有找到满足需求的 chunk 的话，malloc 函数可以很容易到达堆的末尾。代码是如此的明了，base 是一个指向堆的起始位置的指针：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>t_block</span> <span class=nf>find_block</span><span class=p>(</span><span class=n>t_block</span> <span class=o>*</span><span class=n>last</span><span class=p>,</span> <span class=kt>sizt_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>b</span> <span class=o>=</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>b</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;=</span> <span class=n>size</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>last</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个函数返回一个满足需求的 chunk，或者没有合适的就返回 NULL。每一次循环之后，last 变量就会指向上一次访问的 chunk。</p><h3 id=53-扩展堆 data-numberify>5.3 扩展堆<a class="anchor ms-1 d-none" href=#53-扩展堆>#</a></h3><p>假如我们总是找不到合适的 chunk，有时候(尤其是在程序刚开始的时候使用 malloc)我们需要扩展堆。这也是相当简单的一件事：我们移动 break，然后初始化一个新的 block，当然我们需要更新最后一个 block 的 next 字段(实际上就是给链表中添加一个结点)。</p><p>在接下来的开发中，我们需要在<code>s_block</code>结构体的 size 上做一些小技巧，于是定义了一个宏来获取 meta-data block 的 size，现在这个宏的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define BLOCK_SIZE sizeof(struct s_block)
</span></span></span></code></pre></div><p>这些代码平淡无奇，我们只是在<code>sbrk</code>调用失败的使用返回 NULL(我们并没有尝试着去理解为什么)。我们同样不能确定<code>sbrk</code>返回的是上一次的 break，我们仅仅是先保存它然后再移动它。我们可以用<code>last</code>和<code>last->size</code>来计算。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>t_block</span> <span class=nf>extend_heap</span><span class=p>(</span><span class=n>t_block</span> <span class=n>last</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sbrk</span><span class=p>(</span><span class=n>BLOCK_SIZE</span> <span class=o>+</span> <span class=n>s</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>last</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>last</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=54-blocks-分裂 data-numberify>5.4 blocks 分裂<a class="anchor ms-1 d-none" href=#54-blocks-分裂>#</a></h3><p>你可能已经意识到我们使用的是第一个满足需求的 block 而没有考虑它的 size(假如空间非常富裕呢)。如果我们这样做的话，那么我们会浪费掉很多空间(想象一下，你需要 2bytes，然后找到了一个 256bytes 的 block)。第一个解决方案就是分裂 blocks：当一个 chunk 比需要的空间大很多的时候，我们在链表中插入一个新的 chunk。</p><p><picture><img class="img-fluid mx-auto d-block" alt=unsplit_blocks src=https://iliubang.cn/images/2017-03-17/unsplit_blocks.png loading=lazy width=529 height=168></picture></p><p><picture><img class="img-fluid mx-auto d-block" alt=split_blocks src=https://iliubang.cn/images/2017-03-17/split_blocks.png loading=lazy width=529 height=167></picture></p><p>下面的函数只有在空间可以被访问的情况下才会被调用。使用的 size 也必须是对齐的。在这个函数里，我们将做一些指针的算术操作，为了防止错误发生，我们将使用一些小技巧来确保我们的操作在 1byte 的误差范围内（内存 p+1 依赖于 p 指向的类型）。</p><p>我们仅仅在结构体 s_block 中增加了一个字符数组类型的成员。结构体的末尾存在一个简单的数组：数组被放在结构体的末尾，对于我们而言，数组的指针就是 meta-data 的结束。c 语言禁止使用长度为 0 的数组(在 c99 之前)，所以我们定义了一个长度位 1 的字符数组，这也是我们为什么定义了一个代表 s_block 结构体 size 的红的原因。</p><p>**说明：**此处使用到了<a href=https://en.wikipedia.org/wiki/Flexible_array_member target=_blank rel="noopener noreferrer">Flexible array member<i class="fas fa-external-link-square-alt ms-1"></i></a>技巧，该技巧在 c 语言开发中应用非常广泛，例如在 php 内核的 hash table 实现中也用到了，具体可参考鸟哥的博客：<a href=http://www.laruence.com/2009/08/23/1065.html target=_blank rel="noopener noreferrer">深入理解 PHP 之数组(遍历顺序) <i class="fas fa-external-link-square-alt ms-1"></i></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>s_block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>  <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=n>free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>    <span class=n>data</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define BLOCK_SIZE  12 </span><span class=c1>// 3 * 4
</span></span></span></code></pre></div><p>这个扩展并不需要对 extend_heap 做任何修改，因为新的字段并没有被直接使用。</p><p>至此我们来实现<code>split_block</code>函数：该函数通过参数来把 block 切割成一个所需要的 size。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>split_block</span><span class=p>(</span><span class=n>t_block</span> <span class=n>b</span><span class=p>,</span> <span class=kt>sizt_t</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-</span> <span class=n>s</span> <span class=o>-</span> <span class=n>BLOCK_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上述的第三行代码中使用<code>b->data</code>来做指针运算。因为 data 是字符数组类型，我们可以肯定的是误差精确到一个字节范围内。</p><h3 id=55-malloc-函数 data-numberify>5.5 malloc 函数<a class="anchor ms-1 d-none" href=#55-malloc-函数>#</a></h3><p>好了，至此我们可以实现我们的 malloc 函数了。其实就是对前面所实现的函数的包装。我们需要将传入的 size 对齐，然后如前面所描述的那样检测我们是不是第一次调用 malloc 函数。</p><p>首先别忘了 5.2 节中的函数<code>find_block</code>使用到了一个全局变量<code>base</code>。该变量的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=n>base</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span></code></pre></div><p>这是一个<code>void</code>类型的指针，而且被初始化为<code>NULL</code>。malloc 函数首先需要做的事情就是检验<code>base</code>，如果为<code>NULL</code>则说明这是第一次调用，否则开始前面描述的算法：</p><ul><li>查找一个 free 状态的且有足够空间的 chunk;</li><li>如果我们找到了：</li><li><ul><li>尝试着分割这个 block(需要的空间 size 和找到的 block 的 size 的差值足够存放 meta-data 和一个最小的 block(4bytes))</li></ul></li><li><ul><li>将该 chunk 标记为使用状态(b->free = 0)</li></ul></li><li><ul><li>否则：我们扩展堆</li></ul></li></ul><p><strong>关于<code>last</code>变量的使用说明：</strong><code>find_block</code>函数将最后一次访问的 chunk 的指针存放到<code>last</code>中，所以我们可以在扩展堆的时候使用它，从而避免遍历整个 list。</p><ul><li>否则：我们扩展堆（此时堆为空）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>malloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>b</span><span class=p>,</span> <span class=n>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>  <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=nf>align4</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>base</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>last</span> <span class=o>=</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=nf>find_block</span><span class=p>(</span><span class=o>&amp;</span><span class=n>last</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* can we split */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>((</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-</span> <span class=n>s</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=p>(</span><span class=n>BLOCK_SIZE</span> <span class=o>+</span> <span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=nf>split_block</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* No fitting block, extend the heap */</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span> <span class=o>=</span> <span class=nf>extend_heap</span><span class=p>(</span><span class=n>last</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* first time */</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=nf>texted_heap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>base</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=6-calloc-free-和-realloc-函数 data-numberify>6 calloc, free 和 realloc 函数<a class="anchor ms-1 d-none" href=#6-calloc-free-和-realloc-函数>#</a></h2><h3 id=61-calloc data-numberify>6.1 calloc<a class="anchor ms-1 d-none" href=#61-calloc>#</a></h3><p><strong>说明：</strong><code>malloc(2)</code>,<code>calloc(3)</code>这种函数括号中带有数字表示的是函数在系统的 man page 中章节数，通常 Linux 系统章节数遵循以下约定：</p><p>1、Standard commands (标准命令)
2、System calls (系统调用)
3、Library functions (库函数)
4、Special devices (设备说明)
5、File formats (文件格式)
6、Games and toys (游戏和娱乐)
7、Miscellaneous (杂项)
8、Administrative Commands (管理员命令)</p><p><code>calloc(3)</code>也非常的简单：</p><ul><li>首先用正确的 size(两个操作数的产物)来调用 malloc;</li><li>将 block 中的每个 byte 都设置为 0.</li></ul><p>这里我们又使用到了一些小小的技巧：data block 的 size 通常是 4 的倍数，因此将迭代的步长设置为 4bytes。为此，我们使用一个新的指针作为一个 unsigned integer 类型的数组。下面是实现的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>calloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>number</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=o>*</span><span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>s4</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>number</span> <span class=o>*</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s4</span> <span class=o>=</span> <span class=nf>align4</span><span class=p>(</span><span class=n>number</span> <span class=o>*</span> <span class=n>size</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>s4</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>new</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>说明：</strong></p><ol><li>此处 unsigned integer 类型长度为 4bytes 是针对 32 位操作系统，在 64 位系统中已经不适用；</li><li>因为 new 经过 4bytes 对齐后是 4 的倍数，所以其等于长度为<code>number * size / 4</code>的 unsigned integer 类型的数组，数组的每一个元素都有 4bytes，也就是说遍历数组的时候步长实际为 4bytes.</li></ol><h3 id=62-free data-numberify>6.2 free<a class="anchor ms-1 d-none" href=#62-free>#</a></h3><p>快速实现一个<code>free(3)</code>函数是很容易的，但是却不那么实用。我们有两个问题需要解决：一个是查找到要被释放的 chunk，另一个是避免空间碎片。</p><h4 id=621-碎片malloc-函数的诟病 data-numberify>6.2.1 碎片：malloc 函数的诟病<a class="anchor ms-1 d-none" href=#621-碎片malloc-函数的诟病>#</a></h4><p>malloc 函数存在一个主要的问题就是碎片：经过几次 malloc 和 free 调用之后，我们把堆划分成了很多很小的 chunks，每一个 chunk 都很小不足以满足较大的 malloc 分配，但是所有的 chunks 加起来却能满足。这个问题被称作空间碎片问题。虽然不对算法进行修改我们无法阻止由于算法造成的额外碎片，但是我们可以避免其他碎片的来源。</p><p>当我们选择了一个空间比所需空间大很多的空闲 chunk 的时候，我们分隔它。虽然这样做能够更有效的利用内存(新的 chunk 能够被接下来的分配所使用)，但是却产生了更多的碎片。</p><p>一个限制碎片的解决方案是合并被释放的 chunks。当我们释放一个 chunk 的时候，如果与它相邻的 chunk 也是释放状态，那么我们将他们合并成一个较大的 chunk。我们需要做的仅仅是检查当前 chunk 的上一个 chunk 和下一个 chunk。但是如何找到上一个 chunk 呢？下面列举了一些解决方案：</p><ul><li>从起始位置开始查找，会特别慢(尤其是我们已经做了一次查找被释放 chunk 的操作)</li><li>如果我们已经做了查找当前 chunk 的操作，我们可以将上次访问的 chunk 的指针保存起来(就像 find_block 函数中那样)</li><li>将链表改为双向链表</li></ul><p>我们选择了最后一个方案，因为它很简单，而且可以让我们使用一些技巧来查找目标 chunk。因此我们再次修改我们的 struct s_block，但是由于我们还有其他的修改(见下一节)，所以我们将会在后边的修改中呈现其代码。</p><p>于是，我们现在要做的就是合并操作。我们首先实现一个简单的合并函数来合并 chunk 和它的后继(注：前驱，后继，都是链表中的术语)结点。合并前驱结点同理。在下面的代码中我们使用新的字段<code>prev</code>来表示前驱结点。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>t_block</span> <span class=nf>fusion</span><span class=p>(</span><span class=n>t_block</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>free</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>+=</span> <span class=n>BLOCK_SIZE</span> <span class=o>+</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>合并的原理很清晰：如果下一个 chunk 为 free，我们将两个 chunk 的 size 相加，然后再加上 meta-data 的 size 并赋值给当前 chunk 的 size。接着我们将当前 chunk 的后继指向当前结点后继的后继结点，如果这个结点存在的话，将其前驱结点设置为当前结点。</p><h4 id=622-查找正确的-chunk data-numberify>6.2.2 查找正确的 chunk<a class="anchor ms-1 d-none" href=#622-查找正确的-chunk>#</a></h4><p>另一个释放操作的问题是如何高效，正确的查找被 malloc 分配的 chunk。要实现就需要解决下面的问题：</p><ul><li>校验传入的指针是否真的是 malloc 返回的指针；</li><li>查找 meta-data 指针</li></ul><p>我们可以通过范围检测快速排出掉大多数无效指针：如果指针超出了堆的范围，那么就是无效指针。对于没有被排出的指针，我们如何来确保他就一定是被 malloc 返回的呢？</p><p>一个方法是在 block 结构体中加入一些特殊的数字。一个很好的特殊数字就是使用它自身的指针：我们加入一个<code>ptr</code>字段指向该结构体的 data 字段，如果<code>b->ptr == b->data</code>，那么 b 很可能就是能够被 free 操作释放的 block。下面是扩展后的结构体：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>s_block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>          <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>s_block</span>  <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>s_block</span>  <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>             <span class=n>free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span>            <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>            <span class=n>data</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>s_block</span> <span class=o>*</span><span class=n>t_block</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Get the block from an addr */</span>
</span></span><span class=line><span class=cl><span class=n>t_block</span> <span class=nf>get_block</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tmp</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>tmp</span> <span class=o>-=</span> <span class=n>BLOCK_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* valid addr for free */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>valid_addr</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>base</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>&gt;</span> <span class=n>base</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=p>(</span><span class=nf>get_block</span><span class=p>(</span><span class=n>p</span><span class=p>))</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=623-free-函数 data-numberify>6.2.3 free 函数<a class="anchor ms-1 d-none" href=#623-free-函数>#</a></h4><p>free 函数的流程为：首先校验指针然后的到相应的 chunk，将其标记为 free，如果可以的话，进行合并。如果在堆的末尾，我们还要对内存进行释放。</p><p>释放内存的操作也是非常简单的：如果在堆的末尾，我们只需要通过简单的调用<code>brk(2)</code>将 break 移动到 chunk 的起始位置。</p><ul><li>如果指针通过校验：</li><li><ul><li>获取 block 的地址</li></ul></li><li><ul><li>如果前驱结点存在而且 free，移动到前一个 block 并将这两个 blocks 合并</li></ul></li><li><ul><li>同样的操作来合并后继结点</li></ul></li><li><ul><li>如果是最后一个 block，那么释放内存</li></ul></li><li><ul><li>如果已经没有 block 了，那么回到最开始的状态(将 base 设置为 NULL)</li></ul></li><li>如果指针没有通过校验，不需要做任何操作</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>free</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>valid_addr</span><span class=p>(</span><span class=n>p</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=nf>get_block</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>free</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span> <span class=o>=</span> <span class=nf>fusion</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>fusion</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>  <span class=c1>//此处之所以这么写请看fusion函数的实现就会明白
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>base</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>brk</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=63-通过-realloc-函数调整-chunk-的大小 data-numberify>6.3 通过 realloc 函数调整 chunk 的大小<a class="anchor ms-1 d-none" href=#63-通过-realloc-函数调整-chunk-的大小>#</a></h3><p><code>realloc(3)</code>函数和<code>calloc(3)</code>一样很简单。基本上我们只需要多做一个内存拷贝的操作而已。这里我不想用系统提供的<code>memcyp</code>函数，因为我们可以做一个更好的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>  <span class=nf>copy_block</span><span class=p>(</span><span class=n>t_block</span> <span class=n>src</span><span class=p>,</span> <span class=n>t_block</span> <span class=n>dst</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=o>*</span><span class=n>sdata</span><span class=p>,</span> <span class=o>*</span><span class=n>ddata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>  <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>sdata</span> <span class=o>=</span> <span class=n>src</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ddata</span> <span class=o>=</span> <span class=n>dst</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//用到了前面的技巧，用整型数组，使得移动的步长为4bytes(32位系统)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>&lt;</span> <span class=n>src</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>&lt;</span> <span class=n>dst</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ddata</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>sdata</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>一个很天真却有用的 relloc 只需要遵循以下算法规则：</p><ul><li>使用 malloc 分配一个新的大小为给定 size 的 block</li><li>拷贝 data</li><li>释放之前的 block</li><li>返回一个新的指针</li></ul><p>当然，我们想更高效一些：如果我们有足够的空间的话，就不希望再做一个新的分配操作。不同之处在于：</p><ul><li>如果 size 没有改变，或者额外的空间满足需要，即使有少量多余的空间也不足以分割，那么不做任何操作</li><li>如果缩小 block，那么做分割操作</li><li>如果后继 block 是 free 状态，而且能够提供足够的空间，那么合并他们，如果可能的话尝试做分割操作</li></ul><p>下面就是具体的代码实现。不过需要注意的是，<code>realloc(NULL, s)</code>这样的调用是合法的，而且会被替换成<code>malloc(s)</code>调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>realloc</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>      <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span>     <span class=n>b</span><span class=p>,</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span>        <span class=o>*</span><span class=n>newp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>valid_addr</span><span class=p>(</span><span class=n>p</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=nf>align4</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=nf>get_block</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;=</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-</span> <span class=n>s</span> <span class=o>&gt;=</span> <span class=n>BLOCK_SIZE</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>split_block</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>+</span> <span class=n>BLOCK_SIZE</span> <span class=o>+</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>fusion</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-</span> <span class=n>s</span> <span class=o>&gt;=</span> <span class=n>BLOCK_SIZE</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=nf>split_block</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>newp</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>newp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>new</span> <span class=o>=</span> <span class=nf>get_block</span><span class=p>(</span><span class=n>newp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>copy_block</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>new</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>free</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>newp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=631-freebsd-的-reallocf-函数 data-numberify>6.3.1 FreeBSD 的 reallocf 函数<a class="anchor ms-1 d-none" href=#631-freebsd-的-reallocf-函数>#</a></h4><p>FreeBSD 提供了另一个 realloc 函数：<code>realloc(3)</code>函数会在重新分配失败的情况下释放掉原来的指针。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>reallocf</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>newp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>newp</span> <span class=o>=</span> <span class=nf>realloc</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>newp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>newp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=64-总结 data-numberify>6.4 总结<a class="anchor ms-1 d-none" href=#64-总结>#</a></h3><p>现在已经修改好了 block 结构体，我们只需要重写<code>split_block</code>函数和<code>extend_heap</code>函数，并重新定义<code>BLOCK_SIZE</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>s_block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>          <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>s_block</span>  <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>s_block</span>  <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>             <span class=n>free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span>            <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>            <span class=n>data</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>s_block</span>  <span class=o>*</span><span class=n>t_block</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//定义block的size，因为使用sizeof调用的话会将最后一个data[1]也计算进来，
</span></span></span><span class=line><span class=cl><span class=c1>//实际上这个字段没有占用空间
</span></span></span><span class=line><span class=cl><span class=c1>//注意：在c99之后，直接使用char data[]，就不需要此定义，直接使用sizeof即可
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define BLOCK_SIZE 20;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>//仅仅是简单的双向链表操作而已
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>split_block</span><span class=p>(</span><span class=n>t_block</span> <span class=n>b</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span>     <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span> <span class=o>=</span> <span class=p>(</span><span class=n>t_block</span><span class=p>)(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>-</span> <span class=n>s</span> <span class=o>-</span> <span class=n>BLOCK_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>new</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//在堆尾添加一个结点，如果操作失败返回NULL
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>t_block</span> <span class=nf>extend_heap</span><span class=p>(</span><span class=n>t_block</span> <span class=n>last</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=n>sb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t_block</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sb</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=nf>sbrk</span><span class=p>(</span><span class=n>BLOCK_SIZE</span> <span class=o>+</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sb</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>last</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>last</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=7-问题和优化 data-numberify>7 问题和优化<a class="anchor ms-1 d-none" href=#7-问题和优化>#</a></h1><p>通过从无到有实作一个 malloc 让我们对计算机程序的的内存分配和管理有了更深的理解，知道了产生内存碎片的原因以及如何去优化。然而此实作存在很多不足，主要表现为以下几点：</p><ul><li>原文是基于 32 位系统实现的，所以后期可以将其优化为同时兼容 32 位和 64 位系统</li><li>原文中使用的 Flexible array member 是基于 c99 之前的写法，可以优化为 c99 支持的写法</li><li>原文中使用的<code>brk</code>和<code>sbrk</code>已经过时</li></ul></div></div><div class="modal fade" id=rewardModal tabindex=-1 aria-labelledby=rewardModalLabel aria-hidden=true><div class=modal-dialog><div class="modal-content surface"><div class=modal-header><h5 class="modal-title text-surface" id=rewardModalLabel><i class="fas fa-fw fa-coffee me-1"></i>打赏</h5><a href=# data-bs-dismiss=modal class=btn-close aria-label=Close></a></div><div class=modal-body><ul class="nav nav-tabs mb-3" role=tablist><li class="nav-item text-nowrap" role=presentation><a class="nav-link active" id=reward-alipay-tab data-bs-toggle=tab href=#reward-alipay role=tab aria-controls=reward-alipay aria-selected=true><i class="fab fa-fw fa-alipay me-1"></i>支付宝</a></li><li class="nav-item text-nowrap" role=presentation><a class=nav-link id=reward-wechat-tab data-bs-toggle=tab href=#reward-wechat role=tab aria-controls=reward-wechat aria-selected=true><i class="fab fa-fw fa-weixin me-1"></i>微信</a></li></ul><div class=tab-content id=rewardTabContent><div class="tab-pane fade post-reward-content text-center show active" id=reward-alipay role=tabpanel aria-labelledby=reward-alipay-tab><img class="img-fluid post-reward-img" src=https://iliubang.cn/images/reward/alipay.jpg loading=lazy data-viewer-invisible></div><div class="tab-pane fade post-reward-content text-center show" id=reward-wechat role=tabpanel aria-labelledby=reward-wechat-tab><img class="img-fluid post-reward-img" src=https://iliubang.cn/images/reward/wechat.jpg loading=lazy data-viewer-invisible></div></div></div></div></div></div></div><div class=card-footer><div class="post-navs d-flex justify-content-evenly"><div class="post-nav post-prev"><i class="fas fa-fw fa-chevron-down post-prev-icon me-1" data-fa-transform=rotate-90></i>
<a href=https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/>基于c语言的编程语言开发</a></div><div class="post-nav post-next"><a href=https://iliubang.cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/>Java Native Interface（一）</a>
<i class="fas fa-fw fa-chevron-down post-next-icon ms-1" data-fa-transform=rotate-270></i></div></div></div></article><div class="post-copyright mb-3 row card component" id=post-copyright><div class=card-header><h2 class="card-title fs-4 my-2 text-surface">版权</h2></div><div class=card-body><a class="d-flex align-items-center flex-column" target=_blank rel="license noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh><span><i class="fab fa-fw fa-2x fa-creative-commons"></i><i class="fab fa-fw fa-2x fa-creative-commons-by"></i><i class="fab fa-fw fa-2x fa-creative-commons-nc"></i><i class="fab fa-fw fa-2x fa-creative-commons-nd"></i></span>
CC BY-NC-ND 4.0</a></div></div><section class="related-posts row card component"><div class=card-header><h2 class="card-title fs-4 my-2 text-surface">相关文章</h2></div><div class=card-body><ul class="post-list list-unstyled"><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/>基于c语言的编程语言开发</a>
<span class="post-meta post-date float-end">2017-03-15</span><div class="post-summary my-3"><h2 id=preface data-numberify>Preface<a class="anchor ms-1 d-none" href=#preface>#</a></h2><p>当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问&ndash;计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可能滴！在计算机的世界里，他们能够直接识别的只有机器语言。然而，由于机器语言对人类不够友好，所以人们才发明了汇编，c，Java&mldr;许许多多的人类易读的编程语言，所以我个人对编程语言的理解一直是其实他们就是机器语言的语法糖，而编程语言的创造过程，就是定义一种合理的，没有二义性的语法规则，然后就是通过直接或间接的方式实现该语法到机器语言的转换过程。既然是这样的话，那么我们就很容易想到，计算机语言是一个自我完善的过程：首先我们定了一种非常简单的 x1(这里只是用来举例说明，有...</p><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/>阅读更多</a></div></div></li><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/>PHP扩展开发之call_user_func原理和回调函数的实现</a>
<span class="post-meta post-date float-end">2017-03-09</span><div class="post-summary my-3"><h2 id=函数调用 data-numberify>函数调用<a class="anchor ms-1 d-none" href=#函数调用>#</a></h2><p>很多时候，我们需要通过函数名来调用函数，并传递参数，或者把匿名函数作为函数的参数传递，实现回调。当我们在遇到这样的需求的时候，用 php 代码实现起来肯定是非常容易和简单的。但是，当我们在用 c 语言编写 php 扩展的时候，如何来实现这样的功能呢？下面就一起来深入了解 php 内核，看看如何实现。</p><p>在 Zend 引擎中，给我们提供了<code>zend_call_function</code>,<code>call_user_function</code>以及<code>call_user_function_ex</code>函数来帮助我们实现函数调用。在<code>zend_API.h</code>文件中，我们可以看到如下函数原型的声明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ZEND_API</span> <span class=kt>int</span> <span class=nf>zend_call_function</span><span class=p>(...</span></span></span></code></pre></div><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/>阅读更多</a></div></div></li><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/>Java Native Interface（一）</a>
<span class="post-meta post-date float-end">2017-03-17</span><div class="post-summary my-3"><p>最近在整理学习笔记的时候发现了去年年中记录的 JNI 学习笔记，由于存放在了为知笔记中，而如今为知笔记已经不再免费，于是想到了将其重新整理一遍，一来可以巩固所学，二来能将其迁移到本地</p><h2 id=1-简介 data-numberify>1 简介<a class="anchor ms-1 d-none" href=#1-简介>#</a></h2><p>有时候，使用 native code(c/c++)来克服 Java 中的内存管理和性能的局限性是很有必要的。Java 支持 native codes，被称作 Java Native Interface(JNI)。</p><p>JNI 非常难，毕竟它牵涉到了两种编程语言。假设聪明的你对 Java 和 C/C++以及 GCC 编译器已经有所了解。那么下面就一起来一步步学习 JNI 吧。</p><h2 id=2-开始 data-numberify>2 开始<a class="anchor ms-1 d-none" href=#2-开始>#</a></h2><h3 id=21-用-c-语言实现第一个-jni-程序 data-numberify>2.1 用 c 语言实现第一个 JNI 程序<a class="anchor ms-1 d-none" href=#21-用-c-语言实现第一个-jni-程序>#...</a></h3><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/>阅读更多</a></div></div></li></ul></div></section><div class="card component row post-comments" id=post-comments><div class=card-header><h2 class="card-title my-2 fs-4 text-surface">评论</h2></div><div class=card-body><script src=https://utteranc.es/client.js repo=liubang/blog issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></div></div></div></div><aside class="col-lg-4 sidebar d-flex"><div class="container d-flex flex-column"><div class="accordion profile"><div class="accordion-item card row text-center component"><div class="accordion-header card-header border-0" id=profile-header><a class="accordion-button d-lg-none mb-2 shadow-none p-0 bg-transparent text-surface collapsed" type=button data-bs-toggle=collapse data-bs-target=#profile aria-expanded=false aria-controls=profile>Profile</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=profile aria-labelledby=profile-header><div class="col-12 d-flex align-items-center justify-content-center"><picture><img class="profile-avatar rounded-circle" alt=liubang src=https://iliubang.cn/images/profile.webp loading=lazy data-viewer-invisible width=484 height=483></picture></div><div class="col-12 profile-meta"><div class="profile-name fw-fold fs-lg">liubang</div><div class=profile-bio>Whether you are an antelope or a lion, you ought to dash forward without hesitation when the sun rise</div><div class=profile-company><i class="fas fa-fw fa-building"></i>Baidu</div><div class=profile-location><i class="fas fa-fw fa-map-marker-alt"></i>Beijing</div><div class="profile-about text-primary"><i class="fas fa-fw fa-user"></i><a href=https://iliubang.cn/about/>关于</a></div></div><nav class="social-links nav justify-content-center mt-1 justify-content-around"><a class="nav-link social-link" href=mailto:it.liubang@gmail.com title=电子邮箱><i class="fas fa-fw fa-2x fa-envelope"></i></a>
<a class="nav-link social-link" target=_blank href=https://github.com/liubang title=GitHub rel=me><i class="fa-fw fa-2x fab fa-github"></i></a>
<a class="nav-link social-link" target=_blank href=https://weibo.com/2113750192 title=微博 rel=me><i class="fa-fw fa-2x fab fa-weibo"></i></a>
<a class="nav-link social-link" target=_blank href=https://iliubang.cn/index.xml title=RSS rel=me><i class="fas fa-fw fa-2x fa-rss"></i></a></nav></div></div></div><div class="accordion taxonomies-toggle"><section class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent collapsed" type=button data-bs-toggle=collapse data-bs-target=#taxonomies-toggle aria-expanded=false aria-controls=taxonomies-toggle>Taxonomies</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=taxonomies-toggle><ul class="nav nav-pills nav-fill" id=myTab role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=taxonomyTagsTab data-bs-toggle=tab data-bs-target=#taxonomyTags type=button role=tab aria-controls=标签 aria-selected=true>
标签</button></li><li class=nav-item role=presentation><button class=nav-link id=taxonomySeriesTab data-bs-toggle=tab data-bs-target=#taxonomySeries type=button role=tab aria-controls=专栏 aria-selected=true>
专栏</button></li><li class=nav-item role=presentation><button class=nav-link id=taxonomyArchivesTab data-bs-toggle=tab data-bs-target=#taxonomyArchive type=button role=tab aria-controls=taxonomyArchives aria-selected=true>
归档</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=taxonomyTags role=tabpanel aria-labelledby=taxonomyTagsTab tabindex=0><a href=https://iliubang.cn/tags/c++/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c++>c++
<span class="badge badge-sm text-secondary bg-white ms-1">17</span></a>
<a href=https://iliubang.cn/tags/c/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c>c
<span class="badge badge-sm text-secondary bg-white ms-1">14</span></a>
<a href=https://iliubang.cn/tags/php/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=php>php
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=https://iliubang.cn/tags/sp/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=sp>sp
<span class="badge badge-sm text-secondary bg-white ms-1">5</span></a>
<a href=https://iliubang.cn/tags/c++17/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c++17>c++17
<span class="badge badge-sm text-secondary bg-white ms-1">4</span></a>
<a href=https://iliubang.cn/tags/c++11/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c++11>c++11
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags/java/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=Java>Java
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags/jni/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=JNI>JNI
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags/linkedlist/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=LinkedList>LinkedList
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags/unionfind/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=UnionFind>UnionFind
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=全部>全部
<span class="badge badge-sm text-secondary bg-white ms-1">25</span></a></div><div class=tab-pane id=taxonomySeries role=tabpanel aria-labelledby=taxonomySeriesTab tabindex=0><a href=https://iliubang.cn/series/leetcode/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-series me-2 mb-2" title=LeetCode>LeetCode
<span class="badge badge-sm text-secondary bg-white ms-1">9</span></a></div><div class=tab-pane id=taxonomyArchive role=tabpanel aria-labelledby=taxonomyArchiveTab tabindex=0><a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2022>2022 <span class="badge badge-sm text-secondary bg-white ms-1">13</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2021>2021 <span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2020>2020 <span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2019>2019 <span class="badge badge-sm text-secondary bg-white ms-1">2</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2018>2018 <span class="badge badge-sm text-secondary bg-white ms-1">10</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2017>2017 <span class="badge badge-sm text-secondary bg-white ms-1">15</span></a></div></div></div></section></div><div class="accordion posts-toggle"><section class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent collapsed" type=button data-bs-toggle=collapse data-bs-target=#posts-toggle aria-expanded=false aria-controls=posts-toggle>文章</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=posts-toggle><ul class="nav nav-pills nav-fill" id=myTab role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=recent-posts-tab data-bs-toggle=tab data-bs-target=#recent-posts type=button role=tab aria-controls=recent-posts aria-selected=true>
最近文章</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=recent-posts role=tabpanel aria-labelledby=recent-posts-tab tabindex=0><ul class="post-list list-unstyled ms-1"><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/rust/2022-11-13-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E4%BE%8B%E5%8C%96/>Rust和C++: 泛型和特例化</a><div class="post-meta mt-2"><span class=post-date>2022-11-12</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/rust/2022-11-01-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E5%8F%AF%E5%8F%98%E6%80%A7%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/>Rust和C++: 可变性、移动和所有权</a><div class="post-meta mt-2"><span class=post-date>2022-11-01</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/>为什么c++中有了函数指针却还需要std::function</a><div class="post-meta mt-2"><span class=post-date>2022-09-28</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/>使用std::list的splice方法实现LRU Cache</a><div class="post-meta mt-2"><span class=post-date>2022-05-15</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/>深入理解 enable_shared_from_this</a><div class="post-meta mt-2"><span class=post-date>2022-05-03</span></div></div></div></li></ul></div></div></div></section></div><div class="accordion post-toc d-none d-lg-block"><div class="accordion-item row mb-4 card component" id=postTOC><div class="card-header accordion-header"><h2 class="card-title fs-4 my-2 text-surface d-none d-lg-block">目录</h2><a class="accordion-button d-lg-none mb-1 collapsed shadow-none p-0 bg-transparent" type=button data-bs-toggle=collapse data-bs-target=#post-toc aria-expanded=false aria-controls=post-toc>目录</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=post-toc aria-labelledby=post-toc-header><nav id=TableOfContents><ul><li><a href=#1-简介>1 简介</a></li><li><a href=#2-堆brk-和-sbrk-系统调用>2 堆，brk 和 sbrk 系统调用</a><ul><li><a href=#21-进程的内存>2.1 进程的内存</a></li><li><a href=#22-brk2和-sbrk2>2.2 brk(2)和 sbrk(2)</a></li><li><a href=#23-unmapped-region-and-no-mans-land>2.3 Unmapped Region and No-Man&rsquo;s Land</a></li><li><a href=#24-mmap2>2.4 mmap(2)</a></li></ul></li><li><a href=#3-实现一个简陋的-malloc>3 实现一个简陋的 malloc</a><ul><li><a href=#31-原理>3.1 原理</a></li><li><a href=#32-实现>3.2 实现</a></li></ul></li><li><a href=#4-堆>4 堆</a><ul><li><a href=#41-我们需要什么>4.1 我们需要什么</a></li><li><a href=#42-如何表示块信息>4.2 如何表示块信息</a></li></ul></li><li><a href=#5-malloc-的第一个优化版>5 malloc 的第一个优化版</a><ul><li><a href=#51-指针对齐>5.1 指针对齐</a></li><li><a href=#52-查找-chunk第一个优化算法>5.2 查找 chunk:第一个优化算法</a></li><li><a href=#53-扩展堆>5.3 扩展堆</a></li><li><a href=#54-blocks-分裂>5.4 blocks 分裂</a></li><li><a href=#55-malloc-函数>5.5 malloc 函数</a></li></ul></li><li><a href=#6-calloc-free-和-realloc-函数>6 calloc, free 和 realloc 函数</a><ul><li><a href=#61-calloc>6.1 calloc</a></li><li><a href=#62-free>6.2 free</a></li><li><a href=#63-通过-realloc-函数调整-chunk-的大小>6.3 通过 realloc 函数调整 chunk 的大小</a></li><li><a href=#64-总结>6.4 总结</a></li></ul></li></ul></nav></div></div></div></div></aside></div></main><footer class="footer mt-auto py-3 text-center container"><div class="offcanvas offcanvas-bottom h-auto" tabindex=-1 id=offcanvasActionsPanel aria-labelledby=offcanvasActionsPanelLabel><div class=offcanvas-header><h5 class="offcanvas-title fs-4" id=offcanvasActionsPanelLabel><i class="fas fa-fw fa-th-large me-1"></i>
操作</h5><button type=button class="btn-close ms-auto" data-bs-dismiss=offcanvas data-bs-target=offcanvasActionsPanel aria-label=Close></button></div><div class="offcanvas-body mt-2"><div class="actions d-flex overflow-auto align-items-center"><a role=button class="action action-go-back d-flex flex-column align-items-center me-3" href="javascript: window.history.back();"><span class="action-icon mb-2"><i class="fas fa-2x fa-chevron-circle-down" data-fa-transform=rotate-90></i></span> 返回</a>
<a role=button class="action action-reload-page d-flex flex-column align-items-center me-3"><span class="action-icon mb-2"><i class="fas fa-2x fa-redo-alt"></i></span> 刷新</a>
<a role=button class="action action-copy-url d-flex flex-column align-items-center me-3"><span class="action-icon mb-2"><i class="fas fa-2x fa-link"></i></span> 复制链接</a></div></div></div><nav class="social-links nav justify-content-center mb-2"><a class="nav-link social-link" href=mailto:it.liubang@gmail.com title=电子邮箱><i class="fas fa-fw fa-2x fa-envelope"></i></a>
<a class="nav-link social-link" target=_blank href=https://github.com/liubang title=GitHub rel=me><i class="fa-fw fa-2x fab fa-github"></i></a>
<a class="nav-link social-link" target=_blank href=https://weibo.com/2113750192 title=微博 rel=me><i class="fa-fw fa-2x fab fa-weibo"></i></a>
<a class="nav-link social-link" target=_blank href=https://iliubang.cn/index.xml title=RSS rel=me><i class="fas fa-fw fa-2x fa-rss"></i></a></nav><div class="copyright mb-2">Copyright © 2016-2022 LiuBang. All Rights Reserved.</div><div class="powered-by mb-2">Powered by <a class=text-primary href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a> and the <a class=text-primary href=https://github.com/razonyang/hugo-theme-bootstrap target=_blank rel="noopener noreferrer">HBS</a> theme.</div></footer><script data-precache src=https://iliubang.cn/assets/main/bundle.min.535ccd491e59c1e36f487def2396d4d3b40c7fe7d6a4ec85e950b6b9c16b9f04.js integrity="sha256-U1zNSR5ZweNvSH3vI5bU07QMf+fWpOyF6VC2ucFrnwQ=" crossorigin=anonymous defer></script><script data-precache src=https://iliubang.cn/assets/icons/bundle.min.9ecee31369bbabdf120c7ff0229a2fb2761d0b4e2c22bbe1337919b1185f5119.js integrity="sha256-ns7jE2m7q98SDH/wIpovsnYdC04sIrvhM3kZsRhfURk=" crossorigin=anonymous defer></script>
<script data-precache src=https://iliubang.cn/assets/viewer/bundle.min.9f713149f059d05fcb65e7f7c27308e61c384500e80ab1c333c2510a36a5d70c.js integrity="sha256-n3ExSfBZ0F/LZef3wnMI5hw4RQDoCrHDM8JRCjal1ww=" crossorigin=anonymous defer></script>
<script data-precache defer src=https://iliubang.cn/assets/katex/bundle.min.5d4e21071a95ce5b1f635fc99cc98e30d14b157ff223fb4f76117fdf4029c3a5.js integrity="sha256-XU4hBxqVzlsfY1/JnMmOMNFLFX/yI/tPdhF/30Apw6U=" crossorigin=anonymous></script>
<script data-precache defer src=https://iliubang.cn/assets/mermaid/bundle.min.a2e36ade374cbea0ae0def9942abad720f3557402f38002dd138c1ee79e7b71e.js integrity="sha256-ouNq3jdMvqCuDe+ZQqutcg81V0AvOAAt0TjB7nnntx4=" crossorigin=anonymous></script>
<script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("https://iliubang.cn/service-worker.min.js").then(function(e){console.log("Successfully registered service worker",e)}).catch(function(e){console.warn("Error whilst registering service worker",e)})})</script></body></html>