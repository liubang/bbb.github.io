<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>C++ on liubang's blog</title><link>https://iliubang.cn/tags/c++/</link><description>Recent content in C++ on liubang's blog</description><generator>Hugo</generator><language>zh-cn</language><copyright>Copyright © 2016-2024 LiuBang. All Rights Reserved.</copyright><lastBuildDate>Tue, 23 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://iliubang.cn/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>使用LLVM的libFuzzer进行fuzzy test</title><link>https://iliubang.cn/posts/cpp/2023-05-23-%E4%BD%BF%E7%94%A8llvm%E7%9A%84libfuzzer%E8%BF%9B%E8%A1%8Cfuzzy-test/</link><pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2023-05-23-%E4%BD%BF%E7%94%A8llvm%E7%9A%84libfuzzer%E8%BF%9B%E8%A1%8Cfuzzy-test/</guid><description><![CDATA[<h2 id="libfuzzer-简介" data-numberify>libFuzzer 简介<a class="anchor ms-1" href="#libfuzzer-简介"></a></h2>
<p>LLVM libFuzzer 是 LLVM 生态系统中的一个fuzzy test工具，用于自动化地发现软件程序中的漏洞和错误。它通过生成大量的随机输入数据并观察程序的行为来进行fuzzy test。
libFuzzer 是一个基于内存的fuzzy test引擎，使用 LLVM 的插桩技术和代码优化功能来提高测试效率和覆盖率。</p>
<p>以下是 libFuzzer 的一些功能特点：</p>
<ol>
<li>自动化fuzzy test：libFuzzer 提供了一种自动化的fuzzy test方法，可以生成大量的随机输入数据，并在每个输入上运行目标函数进行测试。它通过观察程序的崩溃、断言失败、未定义行为等反馈来发现潜在的问题。</li>
<li>内存安全性：libFuzzer 通过使用 AddressSanitizer (ASan) 和 UndefinedBehaviorSanitizer (UBSan) 等工具来确保fuzzy test过程中的内存安全性。这有助于检测和报告内存错误、缓冲区溢出、使用已释放内存等问题。</li>
<li>代码覆盖率分析：libFuzzer 使用 LLVM 提供的代码覆盖率分析技术，帮助确定已经执行过的代码路径和未执行的代码区域。这有助于评估测试的质量和覆盖范围，并帮助发现潜在的漏洞。</li>
<li>快速收敛：libFuzzer 使用一种称为 &ldquo;回退&rdquo;（Backoff）的策略，以更快地收敛到程序中的漏洞。它会根据测试结果调整输入数据的变异程度，使得能够更快地发现问题并生成更有潜力的测试用例。</li>
<li>灵活性和可定制性：libFuzzer 提供了多种选项和配置参数，使用户能够根据自己的需求进行定制。例如，可以设置最大测试时间、内存消耗限制、覆盖率报告等。</li>
<li>多线程支持：libFuzzer 支持多线程执行，可以利用多核处理器并行进行fuzzy test，加快测试速度。</li>
</ol>

<h2 id="示例" data-numberify>示例<a class="anchor ms-1" href="#示例"></a></h2>
<p>下面是一个使用 libFuzzer 的简单示例</p>
<p>首先我们有一个 test_fuzzy.cpp:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstddef&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdint&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DoSomethingWithData</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> data, std<span style="color:#f92672">::</span>size_t size) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (data[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;h&#39;</span> <span style="color:#f92672">&amp;&amp;</span> data[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#f92672">&amp;&amp;</span> data[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;l&#39;</span> <span style="color:#f92672">&amp;&amp;</span> data[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;l&#39;</span> <span style="color:#f92672">&amp;&amp;</span> data[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">int</span> LLVMFuzzerTestOneInput(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> data, std<span style="color:#f92672">::</span>size_t size) {
</span></span><span style="display:flex;"><span>  DoSomethingWithData(data, size);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用 clang++进行编译：</p>]]></description></item><item><title>为什么c++中有了函数指针却还需要std::function</title><link>https://iliubang.cn/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/</guid><description><![CDATA[<p>在C/C++中，我们经常会像下面的代码那样使用一个指向函数的指针，我们称之为函数指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// demo.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span> a) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>f)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> func;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, f);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的例子中，我们定义了一个函数<code>func</code>，然后通过函数指针<code>f</code>指向<code>func</code>，接着使用<code>print</code>函数打印指针变量<code>f</code>指向
的地址。代码平淡无奇，接着我们编译代码，然后使用<code>objdump -D demo</code>来查看生成的二进制结构如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ae81ff">0000000100003f</span><span style="color:#ae81ff">34</span> <span style="color:#f92672">&lt;</span>_func<span style="color:#f92672">&gt;:</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100003f</span><span style="color:#ae81ff">34</span><span style="color:#f92672">:</span> ff <span style="color:#ae81ff">43</span> <span style="color:#ae81ff">00</span> d1 	sub	sp, sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100003f</span><span style="color:#ae81ff">38</span><span style="color:#f92672">:</span> e0 <span style="color:#ae81ff">0f</span> <span style="color:#ae81ff">00</span> b9 	str	w0, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">12</span>]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100003f</span><span style="color:#ae81ff">3</span>c: e8 <span style="color:#ae81ff">0f</span> <span style="color:#ae81ff">40</span> b9 	ldr	w8, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">12</span>]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100003f</span><span style="color:#ae81ff">40</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">05</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">11</span> 	add	w0, w8, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100003f</span><span style="color:#ae81ff">44</span><span style="color:#f92672">:</span> ff <span style="color:#ae81ff">43</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">91</span> 	add	sp, sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100003f</span><span style="color:#ae81ff">48</span><span style="color:#f92672">:</span> c0 <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">5f</span> d6 	ret
</span></span></code></pre></div><p>上述结果是我在arm64-apple-darwin21.6.0环境下，使用clang
14.0编译出来的结果，gcc编译的结果稍微有点区别，但是对于本文分析问题影响不大。</p>
<p>正如我们所看到的，编译后的<code>func</code>函数位于<code>0x102e0bf34</code>地址，让我们记住这个地址，接着往后看。</p>
<p>接下来我们来运行编译后的二进制文件，很显然它应该输出的是<code>func</code>函数在内存中的地址：</p>
<pre tabindex="0"><code>./demo
0x102e0bf34
</code></pre><p>你猜对了，只是尽管函数指针也是指针，它指向的是内存中的一段代码，而不是内存中的数据。</p>
<p>通常情况下，函数指针作为回调是没有问题的，但是如果考虑到闭包的情况，我们发现函数指针就无能为力了。
因为闭包不仅是一个函数，而且还要能捕获相关的数据，由于函数指针仅仅是指向内存中的一段代码，并没有指向内存中的数据，
所以函数指针无法实现闭包的功能。如果要想实现，就需要做一些改进：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>func) (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">closure</span> {
</span></span><span style="display:flex;"><span>    func f;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>如上，我们定义了一个结构<code>closure</code>，其中包含了两部分，一个指针变量指向一个函数，一个变量保存参数。
也就是说，<code>closure</code>既包含了一段代码，也包含了运行该代码所需要的数据，或者称之为上下文环境，不管它叫什么，总之就是
运行函数所需要的数据。</p>]]></description></item><item><title>使用std::list的splice方法实现LRU Cache</title><link>https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/</guid><description><![CDATA[<h2 id="stdlist-splice-简介" data-numberify>std::list splice 简介<a class="anchor ms-1" href="#stdlist-splice-简介"></a></h2>
<p><code>splice</code>函数通过重新排列链表指针，将一个<code>std::list</code>中的节点转移到另一个<code>std::list</code>中。在元素的转移过程中不会触发元素的拷贝或者移动。因此，调用<code>splice</code>函数之后，元素现有的引用和迭代器都不会失效。</p>
<p>下面是一个将<code>listA</code>中所有节点附加到<code>listB</code>的一个简单代码示例，转移的过程不会导致<code>listA</code>中元素的引用和迭代器失效:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Note: c++17 required below. (For CTAD(Class template argument deducation))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>list listA{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>list listB{<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> listA.begin();   <span style="color:#75715e">// Iterator to 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Append listA to listB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>listB.splice(listB.end(), listA);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// All listA elements transferred to listB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> listB.size() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> listA.size() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;   <span style="color:#75715e">// 6 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prints Below: 4 5 6 1 2 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i : listB) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Iterator still valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;   <span style="color:#75715e">// 1
</span></span></span></code></pre></div><p>当然，我们也可以在不使用<code>splice</code>的情况下将一个 list 中的元素转移到另一个 list 中，但是需要将原 list 中的元素删除，并在目标 list 中插入新的元素。删除和新增元素对于较小的对象（例如 int）是可以接受的，但是对于较大的对象来说，由于需要调用拷贝/移动构造和析构函数，所以成本会很高。</p>]]></description></item><item><title>c++ 中 unique_ptr 的一些使用技巧</title><link>https://iliubang.cn/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link><pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid><description><![CDATA[<h2 id="前言" data-numberify>前言<a class="anchor ms-1" href="#前言"></a></h2>
<p>c++11 对智能指针做了很大的优化，废弃了 c++98 中的<code>auto_ptr</code>，引入了三种新的智能指针：<code>unique_ptr</code>，<code>shared_ptr</code>，<code>weak_ptr</code>。
本文将针对<code>unique_ptr</code>的一些使用技巧做一些整理和归纳。在正式开始之前，我们首先来回顾一下<code>unique_ptr</code>的特点：一个<code>unique_ptr</code>对象内包含一个原始指针，该<code>unique_ptr</code>对象负责管理原始指针的生命周期。
一个<code>unique_ptr</code>对象始终是其关联的原始指针的唯一拥有者。</p>
<p>在了解了<code>unique_ptr</code>的特点之后，我们来具体看看日常开发中<code>unique_ptr</code>的一些使用场景和技巧。</p>

<h2 id="一些场景" data-numberify>一些场景<a class="anchor ms-1" href="#一些场景"></a></h2>

<h3 id="本地对象指针" data-numberify>本地对象指针<a class="anchor ms-1" href="#本地对象指针"></a></h3>
<p>在开发中，我们经常会遇到或者写出类似于下面这样的逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">somefunc</span>() {
</span></span><span style="display:flex;"><span>    Object obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#75715e">/* event 1 */</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> obj;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#75715e">/* event 2 */</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> obj;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> obj;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于这样的代码，写起来很麻烦，看上去也及其丑陋。以前我们常用的一种优化手段就是使用<code>goto</code>，而在 c++11 之后，我们有了一种更加优雅简洁的方式，来对上面的代码进行优化，那就是使用<code>unique_ptr</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">somefunc</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> obj <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">// need c++14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#75715e">/* event 1 */</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#75715e">/* event 2 */</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>只需要将本地指针对象用<code>unique_ptr</code>包装起来，后面无需关心指针释放的问题，整体逻辑看上去更加简洁。</p>]]></description></item><item><title>Expression Templates</title><link>https://iliubang.cn/posts/cpp/2022-04-06-expression-templates/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-04-06-expression-templates/</guid><description><![CDATA[<h2 id="什么是-expression-templates" data-numberify>什么是 Expression Templates<a class="anchor ms-1" href="#什么是-expression-templates"></a></h2>
<p>Expression Templates 是一种 C++ 模板元编程技术，它通过在编译时构建按需执行的计算表达式，从而生成高效的代码。简单来说，通过 Expression Templates，我们可以实现惰性求值和消除因为中间结果而创建的临时变量。</p>

<h2 id="一个常规示例" data-numberify>一个常规示例<a class="anchor ms-1" href="#一个常规示例"></a></h2>
<p>我们构造了一个<code>MyVector</code>类，并且重载了<code>MyVector</code>的<code>+</code>和<code>*</code>操作符，实现两个<code>MyVector</code>中相同下标元素的<code>+</code>和<code>*</code>操作。
对于这样的需求我们很容易写出形如下面代码的一个简单的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cassert&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVector</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyVector(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>size_t n)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> vec_(n)
</span></span><span style="display:flex;"><span>    {}
</span></span><span style="display:flex;"><span>    MyVector(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>size_t n, <span style="color:#66d9ef">const</span> T initvalues)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> vec_(n, initvalues)
</span></span><span style="display:flex;"><span>    {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>size_t size() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> vec_.size(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T <span style="color:#66d9ef">operator</span>[](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>size_t i) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        assert(i <span style="color:#f92672">&lt;</span> size());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> vec_[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span>[](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>size_t i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        assert(i <span style="color:#f92672">&lt;</span> size());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> vec_[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> vec_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">const</span> MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    assert(a.size() <span style="color:#f92672">==</span> b.size());
</span></span><span style="display:flex;"><span>    MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> result(a.size());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> a.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        result[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">const</span> MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    assert(a.size() <span style="color:#f92672">==</span> b.size());
</span></span><span style="display:flex;"><span>    MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> result(a.size());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> a.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        result[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">*</span> b[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> os, <span style="color:#66d9ef">const</span> MyVector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> vec)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> vec.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        os <span style="color:#f92672">&lt;&lt;</span> vec[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    os <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> os;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MyVector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> x(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">5.4</span>);
</span></span><span style="display:flex;"><span>    MyVector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> y(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10.3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span>             ret <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> x <span style="color:#f92672">+</span> y <span style="color:#f92672">*</span> y;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ret <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个实现平淡无奇，相信每个人都能随手写出来。在<a href="https://godbolt.org/z/zTenMfe6G" target="_blank" rel="noopener noreferrer">godbolt<i class="fas fa-external-link-square-alt ms-1"></i></a>上编译成汇编来分析：</p>]]></description></item><item><title>c++中的动态多态和静态多态</title><link>https://iliubang.cn/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/</link><pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/</guid><description><![CDATA[<h2 id="动态多态-dynamic-polymorphism" data-numberify>动态多态 (Dynamic Polymorphism)<a class="anchor ms-1" href="#动态多态-dynamic-polymorphism"></a></h2>
<p>在 c++中为了实现多态，使用了一种动态绑定的技术，这个技术的核心就是虚函数表(virtual table)。下面就简单的说明一下基于虚表的动态绑定的原理，从而更好的与静态多态做比较。</p>
<p>在 c++中，每个包含虚函数的类都有一个虚表。我们来看下面这个类：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// demo.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> vfunc1();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vfunc2</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>         <span style="color:#a6e22e">func1</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>         <span style="color:#a6e22e">func2</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m_data1, m_data2;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>我们可以借助编译器来查看上述类的对象布局：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 使用llvm编译工具</span>
</span></span><span style="display:flex;"><span>clang -Xclang -fdump-record-layouts -stdlib<span style="color:#f92672">=</span>libc++ -c demo.cpp <span style="color:#75715e"># 查看对象布局</span>
</span></span><span style="display:flex;"><span>clang -Xclang -fdump-vtable-layouts -stdlib<span style="color:#f92672">=</span>libc++ -c demo.cpp <span style="color:#75715e"># 查看虚表布局</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用gcc编译工具</span>
</span></span><span style="display:flex;"><span>g++ -fdump-lang-class demo.cpp
</span></span></code></pre></div><p>这里为了便于分析，使用 clang 打印的结果来具体说明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// clang -Xclang -fdump-record-layouts -stdlib=libc++ -c demo.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">***</span> Dumping AST Record Layout
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span>   (A vtable pointer)
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">8</span> <span style="color:#f92672">|</span>   <span style="color:#66d9ef">int</span> m_data1
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">12</span> <span style="color:#f92672">|</span>   <span style="color:#66d9ef">int</span> m_data2
</span></span><span style="display:flex;"><span>           <span style="color:#f92672">|</span> [<span style="color:#66d9ef">sizeof</span><span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>, dsize<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>, align<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>,
</span></span><span style="display:flex;"><span>           <span style="color:#f92672">|</span>  nvsize<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>, nvalign<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// clang -Xclang -fdump-vtable-layouts -stdlib=libc++ -c demo.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Original map
</span></span><span style="display:flex;"><span>Vtable <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;A&#39;</span> (<span style="color:#ae81ff">4</span> entries).
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span> offset_to_top (<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> A RTTI
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">--</span> (A, <span style="color:#ae81ff">0</span>) vtable address <span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>vfunc1()
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>vfunc2()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VTable indices <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;A&#39;</span> (<span style="color:#ae81ff">2</span> entries).
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>vfunc1()
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>vfunc2()
</span></span></code></pre></div><p>根据对象布局可以简单画出<code>class A</code>的对象布局图：</p>]]></description></item><item><title>c++17:constexpr if</title><link>https://iliubang.cn/posts/cpp/2022-03-18-c++17-constexpr_if/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-18-c++17-constexpr_if/</guid><description><![CDATA[<p>constexpr 是 c++11 引入的关键字，用于编译时常量和常量表达式。而 c++17 将这一特性做了增强，引入了 <code>constexpr if</code> ，
使得编译器在编译时(compile time)能够做分支判断，从而有条件的编译代码。</p>
<p>下面可以通过一个简单的例子来看看<code>constexpr if</code>的用法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">auto</span> getValue(T t)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_pointer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>  a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> b <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span><span style="display:flex;"><span>    getValue(a);
</span></span><span style="display:flex;"><span>    getValue(b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其实和普通的条件判断区别不大，只不过<code>constexpr if</code>中的条件是常量表达式，可以在编译时确定条件表达式的结果，从而选择编译对应的分支代码。
我们可以将上述代码编译成汇编来进一步分析：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> getValue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        push    rbp
</span></span><span style="display:flex;"><span>        mov     rbp, rsp
</span></span><span style="display:flex;"><span>        mov     DWORD PTR [rbp<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>], edi
</span></span><span style="display:flex;"><span>        mov     eax, DWORD PTR [rbp<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>        pop     rbp
</span></span><span style="display:flex;"><span>        ret
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> getValue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        push    rbp
</span></span><span style="display:flex;"><span>        mov     rbp, rsp
</span></span><span style="display:flex;"><span>        mov     QWORD PTR [rbp<span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>], rdi
</span></span><span style="display:flex;"><span>        mov     rax, QWORD PTR [rbp<span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span>        mov     eax, DWORD PTR [rax]
</span></span><span style="display:flex;"><span>        pop     rbp
</span></span><span style="display:flex;"><span>        ret
</span></span><span style="display:flex;"><span>......
</span></span></code></pre></div><p>这里可以看到，生成的<code>getValue&lt;int&gt;</code>和<code>getValue&lt;int*&gt;</code>两个版本的函数分别保留了对应类型的分支逻辑，而没有了条件判断。</p>]]></description></item><item><title>c++20:Designated Initializers</title><link>https://iliubang.cn/posts/cpp/2022-03-15-c++20-designated_initializers/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-15-c++20-designated_initializers/</guid><description><![CDATA[<p>对于熟悉 c99 的人来说，Designated Initializers 并不算是什么新鲜事物，然而 c++直到 c++20 才正式支持这一特性。
虽然在 c++20 之前，像 GCC 这样的编译器通过扩展的形式已经对该特性做了支持，但是随着 c++20 将其纳入新标准，这一特性将在所有编译器中得到支持。</p>

<h2 id="基本用法" data-numberify>基本用法<a class="anchor ms-1" href="#基本用法"></a></h2>
<p>Designated Initialization 是聚合初始化(Aggregate Initialization)的一种形式。
在 c++20 中，聚合类型(Aggregate types)是指：</p>
<ul>
<li>数组类型</li>
<li>具备如下特性的 class 类型：</li>
<li>
<ul>
<li>has no private or protected direct non-static data members</li>
</ul>
</li>
<li>
<ul>
<li>has no user-declared or inherited constructors</li>
</ul>
</li>
<li>
<ul>
<li>has no virtual, private, or protected base classes</li>
</ul>
</li>
<li>
<ul>
<li>has no virtual member functions</li>
</ul>
</li>
</ul>
<p>c++20 中的 Designated Initializers 的用法跟 c99 非常相似：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Points</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x{<span style="color:#ae81ff">0.0</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> y{<span style="color:#ae81ff">0.0</span>};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Points p{.x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>, .y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.2</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Points o{.x{<span style="color:#ae81ff">1.1</span>}, .y{<span style="color:#ae81ff">2.2</span>}};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Points x{.x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>, .y{<span style="color:#ae81ff">2.2</span>}};
</span></span></code></pre></div>
<h2 id="优点" data-numberify>优点<a class="anchor ms-1" href="#优点"></a></h2>
<p>使用 Designated Initializers 最大的好处就是能够提升代码的可读性。</p>]]></description></item><item><title>c++元编程之遍历tuple</title><link>https://iliubang.cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</guid><description><![CDATA[<p>对于一个标准的 c++容器来说，我们可以很容易在运行时使用迭代器和 range-based for
loop 来遍历其中的每一个元素。但是对于<code>std::tuple</code>，却不能像普通的容器那样去遍历它。</p>

<h2 id="stdtuple-简介" data-numberify>std::tuple 简介<a class="anchor ms-1" href="#stdtuple-简介"></a></h2>
<p><code>std::tuple</code>是一个具有固定大小，包含不同类型值的集和。与之相似的是<code>std::pair</code>，只不过<code>std::pair</code>只能容纳两个元素，
而<code>std::tuple</code>可以容纳许多元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*&gt;</span> tup {<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">10.5</span>, <span style="color:#e6db74">&#34;hello&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or with CTAD(class template argument deduction), C++17:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>tuple deducedTup {<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">10.5</span>, <span style="color:#e6db74">&#34;hello&#34;</span>}; <span style="color:#75715e">// 自动推导类型
</span></span></span></code></pre></div><p>访问<code>std::pair</code>中的元素只需要访问<code>.first</code>和<code>.second</code>成员即可:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>pair p <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10.5</span>};
</span></span><span style="display:flex;"><span>p.first <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;
</span></span></code></pre></div><p>然而<code>std::tuple</code>并没有类似于<code>.first</code>
<code>.second</code>的成员，标准库中我们只能通过<code>std::get</code>来直接访问其中的元素:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>tuple tp {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span>, <span style="color:#ae81ff">10.5</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// by index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(tp) <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>(tp) <span style="color:#f92672">*=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span>(tp) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; <span style="color:#75715e">// hello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span>(tp) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; <span style="color:#75715e">// world
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// by type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(tp) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; <span style="color:#75715e">// 10.5
</span></span></span></code></pre></div>
<h2 id="如何遍历-tuple" data-numberify>如何遍历 tuple<a class="anchor ms-1" href="#如何遍历-tuple"></a></h2>
<p>对 tuple 有了初步的了解，也知道了如何去获取 tuple 中的元素，那么接下来我们就来一步步构造对 tuple 遍历的方法。</p>

<h3 id="准备工作" data-numberify>准备工作<a class="anchor ms-1" href="#准备工作"></a></h3>
<p>首先我们来编写下面这样一段代码，通过向模板中传递一系列想要访问的元素下标，来完成对<code>tuple</code>的遍历：</p>]]></description></item><item><title>c++17:string_view</title><link>https://iliubang.cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</guid><description><![CDATA[<h2 id="string_view-简介" data-numberify>string_view 简介<a class="anchor ms-1" href="#string_view-简介"></a></h2>
<p><code>std::string_view</code>是 c++17 中新增的一种类型。其核心理念是，能够让我们在传统的 C++03 风格的具体性和泛型编程之间找到一个很好的折衷点。
在 C++17 标准之前，我们通常只能在粗糙的不严谨的模板实现和相对严谨但是有着冗长约束的模板之间做出选择。举个简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// c++03 style
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string name_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> setName(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> new_name);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setName</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> new_name);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不正确的欠约束的模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string name_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">void</span> setName(T<span style="color:#f92672">&amp;&amp;</span> new_name);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正确的但是约束但滑稽冗长的模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string name_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">= </span><span style="color:#a6e22e">decltype</span>(std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;&gt;</span>() <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&amp;&amp;&gt;</span>()) <span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">void</span> setName(T<span style="color:#f92672">&amp;&amp;</span> new_name);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>而有了 <code>string_view</code> 之后，以上代码就可以简化成如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string name_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> setName(std<span style="color:#f92672">::</span>string_view name) { name_ <span style="color:#f92672">=</span> name; }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>string_view</code> 在替代<code>const std::string&amp;</code>参数上取得了巨大的成功，但是有人坚持尝试在任何地方
使用<code>std::string_view</code>来替代<code>const std::string&amp;</code>，这是不对的，例如下面的例子：</p>]]></description></item><item><title>c++编程之标准库和STL</title><link>https://iliubang.cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</link><pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</guid><description><![CDATA[<h2 id="1-c标准库" data-numberify>1. C++标准库<a class="anchor ms-1" href="#1-c标准库"></a></h2>
<p>C++提供了很多库：</p>
<ol>
<li>标准 ANSI C 库都可以移植到 C++中。不同于 ANSI C 库的是，C++中需要在库名前加上&quot;c&quot;前缀，而且去掉&quot;.h&quot;，例如<code>&lt;cmath&gt;</code>对应于 C 语言就是<code>&lt;math.h&gt;</code>，<code>&lt;cstdlib&gt;</code>对应于 C 语言的<code>&lt;stlib.h&gt;</code></li>
<li>C++新增的库，例如 <code>&lt;iostream&gt;</code>，<code>&lt;iomanip&gt;</code>，<code>&lt;string&gt;</code>，<code>&lt;fstream&gt;</code>，<code>&lt;sstream&gt;</code></li>
<li>C++STL：包括容器，迭代器，算法和函数对象</li>
<li>Boost C++库</li>
</ol>

<h3 id="11-c-库和相关头文件" data-numberify>1.1 C 库和相关头文件<a class="anchor ms-1" href="#11-c-库和相关头文件"></a></h3>
<ul>
<li><code>&lt;cstring&gt;</code>：待会解释</li>
<li><code>&lt;cmath&gt;</code>：数学计算相关的库</li>
<li><code>&lt;cstdlib&gt;</code>：通用工具，例如异常（abort, exit, EXIT_SUCCESS, EXIT_FAILURE）；环境相关（getenv）；动态内存管理（malloc, free, calloc, realloc），字符解析（atoi, atof, atol, strtod），
伪随机序列生成（rand, srand, RAND_MAX）；数组搜索和排序（bsearch, qsort）</li>
<li><code>&lt;cctype&gt;</code>：字符类型检测（isalpha, isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl, isgraph, isprint, ispunct, isxdigit）和字符转换（toupper, tolower）</li>
<li><code>&lt;climits&gt;</code>, <code>&lt;cfloat&gt;</code>：Size and limit of integer types (INT_MAX, INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX for long, LLONG_XXX for long long, CHAR_XXX for char) and floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP, DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double)</li>
<li><code>&lt;ctime&gt;</code>：time, difftime, clock, gmttime, localtime, and etc.</li>
<li><code>&lt;cstdio&gt;</code>: C&rsquo;s IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc)</li>
<li><code>&lt;cassert&gt;</code>, <code>&lt;cerrno&gt;</code>, <code>csignal&gt;</code>: 断言和错误</li>
<li><code>&lt;clocale&gt;</code>：本地化</li>
<li><code>&lt;cstdbool&gt;</code>, <code>&lt;cstdint&gt;</code>, <code>&lt;cstddef&gt;</code>, <code>&lt;cstdarg&gt;</code>:</li>
<li><code>&lt;cuchar&gt;</code>, <code>&lt;cwchar&gt;</code>, <code>&lt;cwcchar&gt;</code>: Unicode 字符</li>
</ul>

<h3 id="12-c库和相关头文件" data-numberify>1.2 C++库和相关头文件<a class="anchor ms-1" href="#12-c库和相关头文件"></a></h3>
<ul>
<li><code>&lt;ios&gt;, &lt;iostream&gt;, &lt;istream&gt;, &lt;ostream&gt;, &lt;fstream&gt;, &lt;sstream&gt;</code></li>
<li><code>&lt;iomanip&gt;</code></li>
<li><code>&lt;string&gt;</code></li>
<li><code>&lt;regex&gt;</code></li>
<li><code>&lt;random&gt;</code></li>
<li><code>&lt;limits&gt;</code></li>
<li><code>&lt;stdexception&gt;, &lt;exception&gt;</code></li>
<li><code>&lt;complex&gt;, &lt;tuple&gt;, &lt;valarry&gt;</code></li>
<li><code>&lt;locale&gt;</code></li>
<li><code>&lt;typeinfo&gt;</code></li>
<li><code>&lt;chrono&gt;</code></li>
<li>其它：<code>&lt;codecvt&gt;, &lt;new&gt;, &lt;ratio&gt;, &lt;system_error&gt;, &lt;type_traits&gt;</code></li>
</ul>

<h3 id="13-c-stl-和相关头文件" data-numberify>1.3 C++ STL 和相关头文件<a class="anchor ms-1" href="#13-c-stl-和相关头文件"></a></h3>
<p>STL 主要由以下头文件提供：</p>]]></description></item><item><title>c++编程之字符和字符串</title><link>https://iliubang.cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description><![CDATA[<h2 id="1-字符" data-numberify>1. 字符<a class="anchor ms-1" href="#1-字符"></a></h2>

<h3 id="11-字符类型库头文件cctype" data-numberify>1.1 字符类型库：头文件"cctype"<a class="anchor ms-1" href="#11-字符类型库头文件cctype"></a></h3>
<p>在头文件<code>&lt;cctype&gt;</code>（相当于 C 语言中的<code>&lt;ctype.h&gt;</code>），包含了一下字符处理函数：</p>
<table>
  <thead>
      <tr>
          <th>FUNCTION</th>
          <th>EXAMPLE</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>int isalpha(int ch);//如果 ch 是字母，返回 1，否则 0</td>
          <td></td>
      </tr>
      <tr>
          <td>int isdigit(int ch);//如果 ch 是数字，返回 1，否则 0</td>
          <td></td>
      </tr>
      <tr>
          <td>int isalnum(int ch);//如果 ch 是字母或数字，返回 1，否则 0</td>
          <td></td>
      </tr>
      <tr>
          <td>int isxdigit(int ch);//如果 ch 是十六进制数字[0-9A-Fa-f]，返回 1</td>
          <td></td>
      </tr>
      <tr>
          <td>int isupper(int ch);//如果 ch 是大写字母，返回 1</td>
          <td></td>
      </tr>
      <tr>
          <td>int islower(int ch);//如果 ch 是小写字母，返回 1</td>
          <td></td>
      </tr>
      <tr>
          <td>int toupper(int ch);//转成大写字母</td>
          <td></td>
      </tr>
      <tr>
          <td>int tolower(int ch);//转成小写</td>
          <td></td>
      </tr>
      <tr>
          <td>int isspace(int ch);</td>
          <td></td>
      </tr>
      <tr>
          <td>int ispunct(int ch);//是否是标点符号</td>
          <td></td>
      </tr>
      <tr>
          <td>int iscntrl(int ch);//是否是 control</td>
          <td></td>
      </tr>
      <tr>
          <td>int isprint(int ch);//是否是可打印字符</td>
          <td></td>
      </tr>
      <tr>
          <td>int isgraph(int ch);//是否图形表示</td>
          <td></td>
      </tr>
  </tbody>
</table>

<h2 id="2-字符串c-string-和-string-类" data-numberify>2. 字符串：C-String 和 string 类<a class="anchor ms-1" href="#2-字符串c-string-和-string-类"></a></h2>
<p>回顾一下，我们知道 C++支持两种类型的字符串：</p>]]></description></item><item><title>c++编程之操作符重载</title><link>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link><pubDate>Wed, 14 Mar 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid><description><![CDATA[<p>操作符重载就是指操作符会对不同类型的操作数表现出不同的行为。例如：(a) 按位左移操作符&rsquo;&laquo;&lsquo;在操作流对象的时候就变成了插入操作；(b) <code>*</code>操作符操作于两个数字的时候就是乘法操作，而作用于
地址的时候就是间接寻址操作。C++允许你再用户端扩展操作符重载。</p>
<p>操作符重载就像函数重载那样，同一个函数名可以因为参数不同而同时存在很多版本。</p>

<h2 id="1-string-类中重载的操作符" data-numberify>1. string 类中重载的操作符<a class="anchor ms-1" href="#1-string-类中重载的操作符"></a></h2>
<p>C++的&quot;string&quot;类中重载了以下操作符来作用于&quot;string&quot;对象：</p>
<ul>
<li>字符串比较操作(=,!=,&gt;,&lt;,&gt;=,&lt;=)：例如，使用<code>str1 == str2</code>来比较两个&quot;string&quot;对象</li>
<li>流插入和取出操作(&laquo;,&raquo;)：例如，你可以使用<code>cout &lt;&lt; st1</code>和<code>cin &gt;&gt; str2</code>来输出/输入&quot;string&quot;对象</li>
<li>字符串连接(+,+=)：例如，<code>str1 + str2</code>，将两个&quot;string&quot;对象合并成一个新的&quot;string&quot;对象，<code>str1 += str2</code>将<code>str2</code>追加到<code>str1</code>后</li>
<li>字符索引或下标([])：例如，你可以使用<code>str[n]</code>来获取下标为 n 的字符；或者<code>str[n] = c</code>来修改下标为 n 处的字符。需要注意的是&rsquo;[]&lsquo;操作符不会
做边界检测，也就是说，你需要自己保证下标不会超出边界，你可以使用&quot;string&quot;类的<code>at()</code>函数来做边界检测</li>
<li>赋值(=)：例如，<code>str1 = str2</code>，将<code>str2</code>赋值给<code>str1</code></li>
</ul>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iomanip&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>	string msg1(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>	string msg2(<span style="color:#e6db74">&#34;HELLO&#34;</span>);
</span></span><span style="display:flex;"><span>	string msg3(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> boolalpha;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> (msg1 <span style="color:#f92672">==</span> msg2) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> (msg1 <span style="color:#f92672">==</span> msg3) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> (msg1 <span style="color:#f92672">&lt;</span> msg2) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	string msg4 <span style="color:#f92672">=</span> msg1;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> msg4 <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> (msg1 <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> msg2) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	msg3 <span style="color:#f92672">+=</span> msg2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> msg3 <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> msg1[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> msg1[<span style="color:#ae81ff">99</span>] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
<h2 id="2-用户自定义操作符重载" data-numberify>2. 用户自定义操作符重载<a class="anchor ms-1" href="#2-用户自定义操作符重载"></a></h2>

<h3 id="21-operator函数" data-numberify>2.1 operator"函数<a class="anchor ms-1" href="#21-operator函数"></a></h3>
<p>为了实现操作符重载，我们需要使用一种特殊的函数形式，叫做操作符函数。操作符函数形如：&ldquo;operator Δ()&quot;，Δ 就是将要被重载的操作符。</p>]]></description></item><item><title>c++编程之模板和泛型编程</title><link>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 14 Mar 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid><description><![CDATA[<h2 id="1-简介" data-numberify>1. 简介<a class="anchor ms-1" href="#1-简介"></a></h2>
<p>我们对传递数值或变量给函数都很熟悉，除了传递变量，我们还能传递类型给模板。传递类型就是大家所熟知的泛型编程，因为
我们可以用泛型编写程序，而用特定的类型调用。</p>
<p>泛型编程的目的是为了编写的程序不依赖于数据类型。在 C 语言中，所有的代码都需要绑定到确定的数据类型，这样写的代码只能对特定的数据类型起作用。
而模板可以让我们实现泛型编程。你可以将类型作为参数来构建模板函数和类模板。当你的算法需要作用于多种数据类型的时候，模板就显得及其有用了。</p>
<p>C++的标准模板库(STL)提供了一些常用的容器类模板的实现，例如<code>vector</code>，可以用来存放所有类型的元素。</p>

<h2 id="2-示例stl-中的-vector-类模板" data-numberify>2. 示例：STL 中的 vector 类模板<a class="anchor ms-1" href="#2-示例stl-中的-vector-类模板"></a></h2>
<p>C/C++中的内置数组有一些缺点：</p>
<ol>
<li>它的大小是固定的，需要在声明的时候确定大小，不支持动态声明。你不能在执行期给数组扩容；</li>
<li>数组不提供下标边界校验，你可以使用超出边界的下标</li>
<li>你需要自己实现数组比较，和赋值操作</li>
</ol>
<p>C++提供了一个<code>vector</code>类模板，作为标准模板库(STL)的一部分。<code>vector</code>被定义在<code>&lt;vector&gt;</code>头文件中，属于<code>std</code>命名空间。vector 是最常用的 STL 类，它能够取代数组，并且支持动态分配空间和一些其它操作（例如比较和赋值）。</p>
<p>vector 是一个类模板，它可以被特定类型的实例化，形如：<code>vector&lt;int&gt;</code>, <code>vector&lt;double&gt;</code>, <code>vector&lt;string&gt;</code>。同一个模板能够用于多种类型，而不必为每种类型都写一套实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v1(<span style="color:#ae81ff">5</span>); <span style="color:#75715e">// Create a vector with 5 elements.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Assign values into v1, using array-like index []
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// You can retrieve the size of vector via size()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v1.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		v1[i] <span style="color:#f92672">=</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Print vector content, using at()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v1.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> v1.at(i) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v2;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Assign v1 to v2 memberwise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	v2 <span style="color:#f92672">=</span> v1;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v2.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> v2[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Compare 2 vectors memberwise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> boolalpha <span style="color:#f92672">&lt;&lt;</span> (v1 <span style="color:#f92672">==</span> v2) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Append more elements - synamically allocate memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	v1.push_back(<span style="color:#ae81ff">80</span>);
</span></span><span style="display:flex;"><span>	v1.push_back(<span style="color:#ae81ff">81</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v1.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> v1[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> v3;
</span></span><span style="display:flex;"><span>	v3.push_back(<span style="color:#e6db74">&#34;a for apple&#34;</span>);
</span></span><span style="display:flex;"><span>	v3.push_back(<span style="color:#e6db74">&#34;b for boy&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v3.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> v3[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>说明：</p>]]></description></item><item><title>c++编程之继承和多态</title><link>https://iliubang.cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link><pubDate>Mon, 05 Mar 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid><description><![CDATA[<h2 id="1-继承" data-numberify>1. 继承<a class="anchor ms-1" href="#1-继承"></a></h2>

<h3 id="11-术语" data-numberify>1.1 术语<a class="anchor ms-1" href="#11-术语"></a></h3>
<p>超类（基类）和子类（派生类）：在面向对象程序设计中，我们通常使用继承来避免代码冗余。在 C++中，继承的语法规则如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SubclassName</span> <span style="color:#f92672">:</span> inheritance<span style="color:#f92672">-</span>access<span style="color:#f92672">-</span>specifier SuperclassName {
</span></span><span style="display:flex;"><span>	......
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>子类继承了父类所有的成员，子类也可以定义自己的构造器和成员。</p>
<p><strong>访问标识符</strong>：C++支持三种访问标识符：<code>private</code>，<code>public</code>和<code>protected</code>。一个类的 public 成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问。
一个类的 protected 成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。一个类的 private 成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。</p>
<p><strong>继承访问标识符</strong>：public 继承不改变基类成员的访问权限，private 继承使得基类所有成员在子类中的访问权限变为 private，protected 继承将基类中 public 成员变为子类的 protected 成员，其它成员的访问 权限不变。
基类中的 private 成员不受继承方式的影响，子类永远无权访问。</p>

<h3 id="12-一个示例" data-numberify>1.2 一个示例<a class="anchor ms-1" href="#12-一个示例"></a></h3>
<p><picture><img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-03-05/ClassDiagram_MovablePoint.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="289" height="584" />
</picture>

</p>
<p>MovablePoint.h</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#ifndef MOVING_POINT_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MOVING_POINT_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Point.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MoviablePoint</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Point {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> xSpeed, ySpeed;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	MovablePoint(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, <span style="color:#66d9ef">int</span> xSpeed <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">int</span> ySpeed <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getXSpeed</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getYSpeed</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setXSpeed</span>(<span style="color:#66d9ef">int</span> xSpeed);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setYSpeed</span>(<span style="color:#66d9ef">int</span> ySpeed);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>MovablePoint.cpp</p>]]></description></item><item><title>c++编程之OOP示例</title><link>https://iliubang.cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</link><pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</guid><description><![CDATA[<h2 id="1-示例使用引用的time类" data-numberify>1. 示例：使用引用的"Time"类<a class="anchor ms-1" href="#1-示例使用引用的time类"></a></h2>
<p>回到之前版本的&quot;Time&quot;类，假设我们想增加链式操作，例如<code>t.nextSecond().nextSecond().print()</code>，我们就需要让<code>nextSecond()</code>返回<code>this</code>的一个引用。</p>
<p>Time.h</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Time</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	......
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	Time <span style="color:#f92672">&amp;</span>nextSecond(); <span style="color:#75715e">// Return a reference to &#34;this&#34; instance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在函数原型中，我们申明了一个<code>nextSecond()</code>的成员函数，返回<code>Time</code>对象的引用。返回的引用可以用来继续调用成员函数。</p>
<p>Time.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Increase this instance by one second and return this instance by reference.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Time <span style="color:#f92672">&amp;</span>Time<span style="color:#f92672">::</span>nextSecond() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>second <span style="color:#f92672">==</span> <span style="color:#ae81ff">60</span>) {
</span></span><span style="display:flex;"><span>		second <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>minute <span style="color:#f92672">==</span> <span style="color:#ae81ff">60</span>) {
</span></span><span style="display:flex;"><span>			minute <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>hour <span style="color:#f92672">=</span> <span style="color:#ae81ff">24</span>) {
</span></span><span style="display:flex;"><span>				hour <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; <span style="color:#75715e">// Return this instance by reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				  <span style="color:#75715e">// &#34;this&#34; is a pointer to this instance. *this refers to the instance.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>C++有一个关键字&quot;this&quot;，它保存了一个指向当前实例的指针。也就是说，<code>*this</code>指的是当前实例。</p>]]></description></item><item><title>c++编程之指针，引用和内存动态分配</title><link>https://iliubang.cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</link><pubDate>Fri, 23 Feb 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</guid><description><![CDATA[<p>指针，引用和动态分配内存是 C/C++语言中最强大的特性，这些特性使得程序员能够直接操作计算机中非常珍贵的记忆体资源，进而对内存进行最大性能和高效的使用。
然而指针也是一把双刃剑，它也是 C/C++编程语言中最复杂和最难的特性。</p>
<p>指针之所以这么强大，是因为它允许你通过地址来访问和操作对应记忆体中存储的内容。但是指针也很难被驾驭，使用好的话确实能够大大提升性能，而用的
不好的话，也会导致很多问题，例如著名的内存泄漏和缓冲区溢出，这些 bug 会致使系统发生紊乱。一些新的编程语言（例如 Java 和 C#），将指针从它的语法
中去掉，通过提供自动内存管理的方式来避免使用指针导致的许多问题。</p>
<p>虽然你在编写 C/C++代码的时候可以不使用指针，但是在学习 C/C++的时候很难不提及指针。指针也许不是为新手和笨蛋而设计的。</p>

<h2 id="1-指针变量" data-numberify>1. 指针变量<a class="anchor ms-1" href="#1-指针变量"></a></h2>
<p>计算机记忆体位置有一个地址，对应地址处保存数据。记忆体地址通常是一个数字（一般用十六进制表示），这个数字很难被程序员直接使用。通常一个地址位置
的容量是 8-bit（也就是 1-byte），里面可以存储整数，实数，字符或者字符串，这完全取决于程序员如何解析。</p>
<p>为了减轻程序员使用数字地址和解析数据的负担，早期的编程语言（例如 C 语言）中产生了一种新的变量——这种变量是一个被命名了的变量的位置，它可以存储一个特定类型的值。
取代数字地址的是用名字（或者标识符）直接关联到确定的地址上，而且变量类型（如<code>int</code>, <code>double</code>, <code>char</code>）与之关联，从而简化了对数据的解析。</p>
<p>每个内存地址占 8 位（也就是 1 个字节），一个 4 个字节的<code>int</code>值需要 4 个内存位置。一个 32 位的系统通常使用 32 位的地址。同样的，存储这个 32 位的地址也需要 4 个内存位置。</p>
<p>下面的插图形象的描绘了计算机内存地址，内存中数据，变量名，变量类型以及变量值之间的关系。</p>
<p><picture><img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-02-23/MemoryAddressContent.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="661" height="503" />
</picture>

</p>

<h3 id="11-指针变量" data-numberify>1.1 指针变量<a class="anchor ms-1" href="#11-指针变量"></a></h3>
<p>指针变量（简称指针）基本上跟其他变量一样，都可以用来存放数据，但是跟普通变量不同的是，普通变量存储的是数值，而指针存放的是内存地址。</p>

<h3 id="12-申明指针" data-numberify>1.2 申明指针<a class="anchor ms-1" href="#12-申明指针"></a></h3>
<p>指针在使用前必须先申明。申明指针的语法是在指针名前加上一个<code>*</code>符号。指针必须跟类型关联。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>type <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>type<span style="color:#f92672">*</span> ptr;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>type <span style="color:#f92672">*</span> ptr;
</span></span></code></pre></div><p>例如：</p>]]></description></item><item><title>c++编程之面向对象</title><link>https://iliubang.cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Tue, 13 Feb 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description><![CDATA[<h2 id="1-为什么要使用-oop" data-numberify>1. 为什么要使用 OOP？<a class="anchor ms-1" href="#1-为什么要使用-oop"></a></h2>
<p>假如你想组装一台电脑，你会去硬件商店购买主板、处理器、内存条、硬盘、机箱、电源，然后将它们组装在一起，然后打开电源，电脑就能运行。
你不用考虑主板是 4 重板还是 6 重板，硬盘是什么尺寸，内存是哪里生产的诸如此类的问题。你只需要将这些硬件单元组合在一起，就能期待电脑能够运行。
当然，你需要保证你有正确的接口，比如，如果你的主板只支持 IDE 接口，而你需要购买一个 IDE 的硬盘而不是 SCSI 硬盘，又例如你需要选择一个合适速率的
内存。即便如此，将硬件组件组装成一台机器也没有任何难度。</p>
<p>同样的，一辆车也是由多个部分组装起来的，例如底盘、车门、引擎、车轮、刹车和传动装置。这些组件都是可复用的。比如车轮，就能够被用于很多辆同型号的骑车上。</p>
<p>像电脑和汽车这样的硬件能够用可复用的部分组装起来。那么软件是否也是如此呢？我们是否能够将不同地方的程序片段“组装”起来，然后期待程序能正常运行呢？
答案显然是 no！跟硬件不同的是，很难从软件片段中“组装”一个应用。自从计算机 60 年前问世以来，人们写了大量的程式码。然而，对于每一个新的应用程序，我们都需要
重新造轮子。</p>
<p>为什么要重新造轮子呢？</p>

<h3 id="11-传统的面向过程的编程语言" data-numberify>1.1 传统的面向过程的编程语言<a class="anchor ms-1" href="#11-传统的面向过程的编程语言"></a></h3>
<p><picture><img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-02-13/OOP_CFunction.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="326" height="335" />
</picture>

</p>
<p>传统的面向过程的编程语言（例如 C 和 Pascal）在创建可重用组件方面遇到了一些显著的缺陷：</p>
<ol>
<li>
<p>程序是由函数组织起来的。函数通常是不可重用的，我们很难将一个函数直接拷贝到别的地方去使用，因为函数很有可能引用了头文件，或者全局变量，或者调用了其他函数。
换句话说，函数不能很好的封装成一个独立的可重用单元。</p>
</li>
<li>
<p>面向过程的语言不适合高层抽象来解决现实生活中的问题。例如 c 程序使用&quot;if-else&quot;, &ldquo;for-loop&rdquo;, &ldquo;array&rdquo;, &ldquo;function&rdquo;, &ldquo;pointer&quot;等结构，这些结构很低阶而且很难抽象形如
Customer Relationship Management (CRM) 系统或者电脑足球游戏。</p>
</li>
</ol>
<p>简而言之，传统的面向过程的编程语言将数据结构和算法单元分开了。</p>

<h3 id="12-面向对象的编程语言" data-numberify>1.2 面向对象的编程语言<a class="anchor ms-1" href="#12-面向对象的编程语言"></a></h3>
<p><picture><img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-02-13/OOP_Objects.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="538" height="351" />
</picture>

</p>
<p>面向对象的编程语言就是被设计来克服这些问题的。</p>
<ol>
<li>
<p>OOP 的基础单元是类。类将静态属性和动态行为封装在一起，同时指定一些公开的接口来供人使用。由于相比于函数，类有很好的封装性，所以很容易重用。换句话说，类将数据和算法结合在了一起。</p>
</li>
<li>
<p>面向对象的编程语言为解决现实问题的高阶抽象提供了保证。面向过程的编程语言迫使人们把注意力放在计算机结构（如：内存，位，字节，数组）上，而不是放在要解决的问题本身。面向对象的编程语言
能够让我们更专注于问题本身，使用程序对象来表示和抽象问题中的各种实体。</p>
</li>
</ol>
<p>举个例子，假设你要写一个足球游戏，很难用面向过程的语言建立模型。但是使用 OOP，可以很容易将现实事物同程序之间建立模型：</p>
<ul>
<li>Player：属性包含 name, number, location 等待，操作有 run, jump, kick-the-ball&hellip;</li>
<li>Ball:</li>
<li>Reference:</li>
<li>Field:</li>
<li>Audience:</li>
<li>Weather:</li>
</ul>
<p>最重要的是，这其中的一些类（例如：Ball 和 Audience）可以在其他程序中复用。</p>]]></description></item></channel></rss>