<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>c on liubang's blog</title><link>https://iliubang.cn/tags/c/</link><description>Recent content in c on liubang's blog</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2016-2022 LiuBang. All Rights Reserved.</copyright><lastBuildDate>Sun, 18 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://iliubang.cn/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>使用c语言模拟lisp语法</title><link>https://iliubang.cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</link><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</guid><description><![CDATA[使用 c 语言的 macro 操作，能够很简单的用 c 语言模拟 lisp 语法。 下面我们来定义 lisp.h 头文件# #ifndef LISP_H_OTE1HWPK #define LISP_H_OTE1HWPK #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define define(ret, name, args, block) \ ret name args { return block; } #define if(expr, block1, block2) \ expr ? block1 : block2 #define]]></description></item><item><title>动态连接器技巧之使用LD_PRELOAD改变程序的行为</title><link>https://iliubang.cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</link><pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</guid><description><![CDATA[我们有这样一段简单的代码，用来输出 10 个[0, 100)的随机数： // random.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main() { srand(time(NULL)); int i = 10; while (i--) printf(&#34;%d\n&#34;, rand() % 100); return 0; } 编译运行： liubang@venux-dev:~$ gcc random.c -o random liubang@venux-dev:~$ ./random 44 46]]></description></item><item><title>多线程编程</title><link>https://iliubang.cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</guid><description>开始之前# 这篇文章主要是为了帮助大家熟悉 POSIX 线程库以及在实际开发中使用它的特性。我们会具体讲解如何利用这个线程库定义的不同工具 来解决编程中的问</description></item><item><title>PHP7虚拟机</title><link>https://iliubang.cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html 写这篇文章的</description></item><item><title>PHP和线程</title><link>https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>Thu, 12 Oct 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</guid><description>原文地址http://blog.jpauli.tech/2017/01/12/threads-and-php.html 前言# PHP 和线程，单凭这</description></item><item><title>理解c语言中的声明</title><link>https://iliubang.cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</link><pubDate>Tue, 12 Sep 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</guid><description>在阅读优秀的 c 语言开源程式的时候，我们经常会看到各种复杂的声明，顿时会让我们怀疑人生，怀疑自己是否真的看得懂 c 语言。然而冷静三秒钟，透过现象</description></item><item><title>PHP扩展开发之迭代器</title><link>https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>Mon, 28 Aug 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>preface# 在之前的文章中，我们已经实现了一些 object handlers 来将我们的 ArrayBuffer 整合到 php 中。但是美中不足的是，我们的 ArrayBufferView 并不支持迭代器操作。也就是它不能像 php 中的数组那样使</description></item><item><title>PHP扩展开发之对象处理器(Object Handlers)</title><link>https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>Sun, 27 Aug 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</guid><description>Object Handlers# 在前面的博文中，已经介绍过一些 object handlers 了，也特别介绍了如何通过指定 handlers 来创建一个自定义的结构和使用clone_obj来对自定义的结构进行克隆操</description></item><item><title>PHP扩展开发之打造一个简易的ArrayBuffer</title><link>https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</link><pubDate>Fri, 25 Aug 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</guid><description>ArrayBuffer 简介# ArrayBuffer 又叫二进制数组，是一个用来表示通用的，固定长度的二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容， 而是创建一个表示特定格式的 buffer 的类型化数组</description></item><item><title>PHP扩展开发之自定义对象的存储</title><link>https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</link><pubDate>Thu, 24 Aug 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</guid><description>前言# 对于 php 扩展开发，很多人可能已经不那么陌生了，zend 引擎为了们提供了非常丰富了函数和 macro，来帮助我们很快速的创建一个标准的 php 类，</description></item><item><title>c语言之struct</title><link>https://iliubang.cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</link><pubDate>Mon, 21 Aug 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</guid><description>struct# 在 c 语言中，结构体(struct)是一种复合数据类型，用来将一系列相同或不同类型的变量聚集在同一个内存区间内并赋予同一个名字，使得通过一个</description></item><item><title>彻底掌握malloc</title><link>https://iliubang.cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</link><pubDate>Fri, 17 Mar 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</guid><description>说明：参考文献地址 A Malloc Tutorial 1 简介# malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一</description></item><item><title>基于c语言的编程语言开发</title><link>https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</link><pubDate>Wed, 15 Mar 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</guid><description>Preface# 当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问&amp;ndash;计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可</description></item><item><title>PHP扩展开发之call_user_func原理和回调函数的实现</title><link>https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 09 Mar 2017 00:00:00 +0000</pubDate><guid>https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>函数调用# 很多时候，我们需要通过函数名来调用函数，并传递参数，或者把匿名函数作为函数的参数传递，实现回调。当我们在遇到这样的需求的时候，用 php</description></item></channel></rss>