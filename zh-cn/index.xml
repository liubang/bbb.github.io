<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>liubang's blog</title><link>/zh-cn/</link><description>Recent content on liubang's blog</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2016-{year} LiuBang. All Rights Reserved.</copyright><lastBuildDate>2022-03-23</lastBuildDate><atom:link href="/zh-cn/index.xml" rel="self" type="application/rss+xml"/><item><title>curiously recurring template pattern</title><link>/zh-cn/posts/cpp/2022-03-23-c++curiously_recurring_template_pattern/</link><pubDate>2022-03-23</pubDate><guid>/zh-cn/posts/cpp/2022-03-23-c++curiously_recurring_template_pattern/</guid><description>简介 Curiously recurring template pattern 简称 CRTP, 是 c++模板编程中的惯用模式，其主要特点是把派生类作为基类的模板参数。 CRTP 的一般写法为： 1template&amp;lt;class T&amp;gt; 2class Base 3{ 4// methods within Base can use template to access members of Derived 5};</description></item><item><title>c++17:constexpr if</title><link>/zh-cn/posts/cpp/2022-03-18-c++17-constexpr_if/</link><pubDate>2022-03-18</pubDate><guid>/zh-cn/posts/cpp/2022-03-18-c++17-constexpr_if/</guid><description>constexpr 是 c++11 引入的关键字，用于编译时常量和常量表达式。而 c++17 将这一特性做了增强，引入了 constexpr if ， 使得编译器在编译时(compile time)能够做分支判</description></item><item><title>c++20:Designated Initializers</title><link>/zh-cn/posts/cpp/2022-03-15-c++20-designated_initializers/</link><pubDate>2022-03-15</pubDate><guid>/zh-cn/posts/cpp/2022-03-15-c++20-designated_initializers/</guid><description>对于熟悉 c99 的人来说，Designated Initializers 并不算是什么新鲜事物，然而 c++直到 c++20 才正式支持这一特性。 虽然在 c++20 之前，像 GCC 这样的编译器通过扩展的</description></item><item><title>c++元编程之遍历tuple</title><link>/zh-cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</link><pubDate>2022-02-22</pubDate><guid>/zh-cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</guid><description>对于一个标准的 c++容器来说，我们可以很容易在运行时使用迭代器和 range-based for loop 来遍历其中的每一个元素。但是对于std::tuple，却不能像普通的容</description></item><item><title>c++17:string_view</title><link>/zh-cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</link><pubDate>2022-02-14</pubDate><guid>/zh-cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</guid><description>string_view 简介 std::string_view是 c++17 中新增的一种类型。其核心理念是，能够让我们在传统的 C++03 风格的具体性和泛型编程之间找到一个很好的折衷点</description></item><item><title>LevelDB 源码阅读之 Compaction</title><link>/zh-cn/posts/storage/2021-01-12-leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bcompaction/</link><pubDate>2021-01-12</pubDate><guid>/zh-cn/posts/storage/2021-01-12-leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bcompaction/</guid><description>1. 概览 要谈论 LevelDB 的 Compaction 就不得不从 LevelDB 的整个数据写入流程入手。LevelDB 的基本写入流程大致为： 数据先写入到 WAL 日志中，做持久化 然后数据同步到mut</description></item><item><title>分布式协议</title><link>/zh-cn/posts/inf/2020-05-25-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/</link><pubDate>2020-05-25</pubDate><guid>/zh-cn/posts/inf/2020-05-25-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/</guid><description>拜占庭将军问题 简介 在可能存在叛军的情况下，采用合适的通讯协议，让多个将军达成共识，执行统一的作战计划 二忠一叛难题 它是分布式领域最复杂的容错模</description></item><item><title>使用c语言模拟lisp语法</title><link>/zh-cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</link><pubDate>2019-08-18</pubDate><guid>/zh-cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</guid><description>使用 c 语言的 macro 操作，能够很简单的用 c 语言模拟 lisp 语法。 下面我们来定义 lisp.h 头文件 1#ifndef LISP_H_OTE1HWPK 2#define LISP_H_OTE1HWPK 34#include &amp;lt;stdio.h&amp;gt; 5#include &amp;lt;stdlib.h&amp;gt; 67#define define(ret, name, args, block) \ 8ret name args { return block; } 910#define if(expr, block1, block2) \ 11expr ? block1 : block2 1213#define eq(a,</description></item><item><title>动态连接器技巧之使用LD_PRELOAD改变程序的行为</title><link>/zh-cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</link><pubDate>2019-07-18</pubDate><guid>/zh-cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</guid><description>我们有这样一段简单的代码，用来输出 10 个[0, 100)的随机数： 1// random.c 2#include &amp;lt;stdio.h&amp;gt;3#include &amp;lt;stdlib.h&amp;gt;4#include &amp;lt;time.h&amp;gt;5 6int main() { 7srand(time(NULL)); 8int i = 10; 9while (i--) printf(&amp;#34;%d\n&amp;#34;, rand() % 100); 10return 0; 11} 编译运行： 1liubang@venux-dev:~$ gcc random.c -o random 2liubang@venux-dev:~$ ./random 344 446 597 651</description></item><item><title>多线程编程</title><link>/zh-cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link><pubDate>2018-12-05</pubDate><guid>/zh-cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</guid><description>开始之前 这篇文章主要是为了帮助大家熟悉 POSIX 线程库以及在实际开发中使用它的特性。我们会具体讲解如何利用这个线程库定义的不同工具 来解决编程中的问题</description></item><item><title>使用正则表达式开发一个高性能路由</title><link>/zh-cn/posts/php/2018-04-16-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E8%B7%AF%E7%94%B1/</link><pubDate>2018-04-16</pubDate><guid>/zh-cn/posts/php/2018-04-16-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E8%B7%AF%E7%94%B1/</guid><description>原文地址：http://nikic.github.io/2014/02/18/Fast-request-routing-using-regu</description></item><item><title>c++编程之标准库和STL</title><link>/zh-cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</link><pubDate>2018-03-19</pubDate><guid>/zh-cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</guid><description>1. C++标准库 C++提供了很多库： 标准 ANSI C 库都可以移植到 C++中。不同于 ANSI C 库的是，C++中需要在库名前加上&amp;quot;c&amp;quot;前缀，</description></item><item><title>c++编程之字符和字符串</title><link>/zh-cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>2018-03-15</pubDate><guid>/zh-cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>1. 字符 1.1 字符类型库：头文件\ 在头文件&amp;lt;cctype&amp;gt;（相当于 C 语言中的&amp;lt;ctype.h&amp;gt;），包含了一下字符处理函数：</description></item><item><title>c++编程之操作符重载</title><link>/zh-cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link><pubDate>2018-03-14</pubDate><guid>/zh-cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid><description>操作符重载就是指操作符会对不同类型的操作数表现出不同的行为。例如：(a) 按位左移操作符&amp;rsquo;&amp;laquo;&amp;lsquo;在操作流对象</description></item><item><title>c++编程之模板和泛型编程</title><link>/zh-cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link><pubDate>2018-03-14</pubDate><guid>/zh-cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid><description>1. 简介 我们对传递数值或变量给函数都很熟悉，除了传递变量，我们还能传递类型给模板。传递类型就是大家所熟知的泛型编程，因为 我们可以用泛型编写程序</description></item><item><title>c++编程之继承和多态</title><link>/zh-cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link><pubDate>2018-03-05</pubDate><guid>/zh-cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid><description>1. 继承 1.1 术语 超类（基类）和子类（派生类）：在面向对象程序设计中，我们通常使用继承来避免代码冗余。在 C++中，继承的语法规则如下： 1class SubclassName : inheritance-access-specifier SuperclassName {</description></item><item><title>c++编程之OOP示例</title><link>/zh-cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</link><pubDate>2018-03-02</pubDate><guid>/zh-cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</guid><description>1. 示例：使用引用的"Time"类 回到之前版本的&amp;quot;Time&amp;quot;类，假设我们想增加链式操作，例如t.nextSecond().</description></item><item><title>c++编程之指针，引用和内存动态分配</title><link>/zh-cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</link><pubDate>2018-02-23</pubDate><guid>/zh-cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</guid><description>指针，引用和动态分配内存是 C/C++语言中最强大的特性，这些特性使得程序员能够直接操作计算机中非常珍贵的记忆体资源，进而对内存进行最大性能和</description></item><item><title>c++编程之面向对象</title><link>/zh-cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>2018-02-13</pubDate><guid>/zh-cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>1. 为什么要使用 OOP？ 假如你想组装一台电脑，你会去硬件商店购买主板、处理器、内存条、硬盘、机箱、电源，然后将它们组装在一起，然后打开电源，电</description></item><item><title>php7虚拟机</title><link>/zh-cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>2017-11-29</pubDate><guid>/zh-cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html 写这篇文章的</description></item><item><title>php和线程</title><link>/zh-cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>2017-10-12</pubDate><guid>/zh-cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</guid><description>原文地址http://blog.jpauli.tech/2017/01/12/threads-and-php.html 前言 PHP 和线程，单凭这简</description></item><item><title>理解c语言中的声明</title><link>/zh-cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</link><pubDate>2017-09-12</pubDate><guid>/zh-cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</guid><description>在阅读优秀的 c 语言开源程式的时候，我们经常会看到各种复杂的声明，顿时会让我们怀疑人生，怀疑自己是否真的看得懂 c 语言。然而冷静三秒钟，透过现象</description></item><item><title>php扩展开发之迭代器</title><link>/zh-cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>2017-08-28</pubDate><guid>/zh-cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>preface 在之前的文章中，我们已经实现了一些 object handlers 来将我们的 ArrayBuffer 整合到 php 中。但是美中不足的是，我们的 ArrayBufferView 并不支持迭代器操作。也就是它不能像 php 中的数组那样使</description></item><item><title>php扩展开发之对象处理器(Object Handlers)</title><link>/zh-cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>2017-08-27</pubDate><guid>/zh-cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</guid><description>Object Handlers 在前面的博文中，已经介绍过一些 object handlers 了，也特别介绍了如何通过指定 handlers 来创建一个自定义的结构和使用clone_obj来对自定义的结构进行克隆操</description></item><item><title>php扩展开发之打造一个简易的ArrayBuffer</title><link>/zh-cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</link><pubDate>2017-08-25</pubDate><guid>/zh-cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</guid><description>ArrayBuffer 简介 ArrayBuffer 又叫二进制数组，是一个用来表示通用的，固定长度的二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容， 而是创建一个表示特定格式的 buffer 的类型化数组对</description></item><item><title>php扩展开发之自定义对象的存储</title><link>/zh-cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</link><pubDate>2017-08-24</pubDate><guid>/zh-cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</guid><description>前言 对于 php 扩展开发，很多人可能已经不那么陌生了，zend 引擎为了们提供了非常丰富了函数和 macro，来帮助我们很快速的创建一个标准的 php 类，然</description></item><item><title>数据结构之hashtable</title><link>/zh-cn/posts/ds/2017-08-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bhashtable/</link><pubDate>2017-08-22</pubDate><guid>/zh-cn/posts/ds/2017-08-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bhashtable/</guid><description>hashtable 哈希表又叫散列表，是实现字典操作的中有效数据结构。通常来说，一个 hash table 包含了一个数据，其中的数据通过 index 来访问。 而 hash table 的基本原理就是通过 hash 函数</description></item><item><title>c语言之struct</title><link>/zh-cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</link><pubDate>2017-08-21</pubDate><guid>/zh-cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</guid><description>struct 在 c 语言中，结构体(struct)是一种复合数据类型，用来将一系列相同或不同类型的变量聚集在同一个内存区间内并赋予同一个名字，使得通过一个</description></item><item><title>Java Native Interface（三）</title><link>/zh-cn/posts/java/2017-03-20-java_native_interface%E4%B8%89/</link><pubDate>2017-03-20</pubDate><guid>/zh-cn/posts/java/2017-03-20-java_native_interface%E4%B8%89/</guid><description>前面系统研究了 JNI 的相关操作，下面就来小试牛刀，做一个实际的练习。 记得去年我曾经用 C 语言写过一个 PHP 的 md5 扩展函数，那么今天就花一点点时间用 JNI 来实</description></item><item><title>Java Native Interface（二）</title><link>/zh-cn/posts/java/2017-03-20-java_native_interface%E4%BA%8C/</link><pubDate>2017-03-20</pubDate><guid>/zh-cn/posts/java/2017-03-20-java_native_interface%E4%BA%8C/</guid><description>JNI 基础 JNI 中定义了一下类型来对应到相应的 Java 的数据类型: 1. Java 基本数据类型: jint,jbyte,jshort,jlong,jfloat,jdou</description></item><item><title>Java Native Interface（一）</title><link>/zh-cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/</link><pubDate>2017-03-17</pubDate><guid>/zh-cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/</guid><description>最近在整理学习笔记的时候发现了去年年中记录的 JNI 学习笔记，由于存放在了为知笔记中，而如今为知笔记已经不再免费，于是想到了将其重新整理一遍，一来</description></item><item><title>彻底掌握malloc</title><link>/zh-cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</link><pubDate>2017-03-17</pubDate><guid>/zh-cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</guid><description>说明：参考文献地址 A Malloc Tutorial 1 简介 malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一个</description></item><item><title>基于c语言的编程语言开发</title><link>/zh-cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</link><pubDate>2017-03-15</pubDate><guid>/zh-cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</guid><description>Preface 当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问&amp;ndash;计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可</description></item><item><title>php扩展开发之call_user_func原理和回调函数的实现</title><link>/zh-cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>2017-03-09</pubDate><guid>/zh-cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>函数调用 很多时候，我们需要通过函数名来调用函数，并传递参数，或者把匿名函数作为函数的参数传递，实现回调。当我们在遇到这样的需求的时候，用 php 代</description></item><item><title>Offline</title><link>/zh-cn/offline/</link><pubDate>0001-01-01</pubDate><guid>/zh-cn/offline/</guid><description/></item></channel></rss>